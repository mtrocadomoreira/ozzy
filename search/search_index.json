{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":""},{"location":"#welcome-to","title":"Welcome to","text":"PIC simulation data analysis for the lazy and impatient <p>Ozzy is a data visualization and data wrangling tool geared towards particle-in-cell (PIC) simulations and the plasma physics community. Ozzy's philosophy is to make the analysis of simulation data originating from multiple simulation codes and often contained in large files as easy as possible by building on the powerful features of the xarray package.</p> <p> Get started </p>"},{"location":"#why-ozzy","title":"Why ozzy?","text":"<ul> <li> <p> Any simulation code</p> <p>Read and plot simulation data written by any PIC simulation code. Write the backend to parse the data once and move on.</p> <p> Reading files</p> </li> <li> <p> Labeled dimensions</p> <p>Think like a physicist, not like a software engineer. You'll never have to wonder which numerical index corresponds to the \\(x\\) dimension of that array again.</p> <p> Indexing</p> </li> <li> <p> Keep the metadata</p> <p>Which file was this again? Let the code stay organized so you don't have to. Attributes go where the array goes.</p> <p> Data objects</p> </li> <li> <p> No file size too large</p> <p>Chunking and lazy-loading of large data files (ugh, right?) are handled automatically by xarray and Dask.</p> <p> Data chunking and lazy-loading</p> </li> <li> <p> Fast and furious</p> <p>Vectorized operations, fast Pandas-like indexing, and more to make your analysis run even faster.</p> <p> Notes on speed</p> </li> <li> <p> Stay flexible</p> <p>We embrace xarray and Dask, but you don't have to. Easily manipulate your data as trusty NumPy arrays whenever convenient.</p> <p> Data analysis</p> </li> <li> <p> Beautiful plots with one line of code</p> <p>Ozzy lays the groundwork using the dataset's metadata.</p> <p> Plotting</p> </li> <li> <p> Open Source, MIT</p> <p>Ozzy is licensed under MIT and available on GitHub.</p> <p> License</p> </li> </ul>"},{"location":"#acknowledgment","title":"Acknowledgment","text":"<p>Please consider acknowledging ozzy if you use it to produce images or results published in a scientific publication, for example by including the following text in the acknowledgments or citing ozzy's Zenodo reference<sup>1</sup>:</p> <p>The data and plots in this publication were processed with ozzy<sup>1</sup>, a freely available data visualization and analysis package.</p> <p>In addition, please note that the plotting submodule of ozzy uses two color maps developed by Fabio Crameri (licensed under an MIT license) by default: <code>vik</code> (diverging) and <code>lipari</code> (sequential). These color maps should be acknowledged if used in a published image, for example with:</p> <p>The Scientific colour map lipari<sup>2</sup> is used in this study to prevent visual distortion of the data and exclusion of readers with colour-vision deficiencies<sup>3</sup>.</p> <p>See the \"Plotting\" section of the User Guide for more information.</p> <ol> <li> <p>M. Moreira, \u201cOzzy: A flexible Python package for PIC simulation data analysis and visualization\u201d. Zenodo, Jul. 16, 2024. doi: 10.5281/zenodo.12752995.\u00a0\u21a9\u21a9</p> </li> <li> <p>F. Crameri, \"Scientific colour maps\". Zenodo, Oct. 05, 2023. doi: 10.5281/zenodo.8409685.\u00a0\u21a9</p> </li> <li> <p>F. Crameri, G.E. Shephard, and P.J. Heron, \"The misuse of colour in science communication\". Nat. Commun. 11, 5444 (2020). doi: 10.1038/s41467-020-19160-7.\u00a0\u21a9</p> </li> </ol>"},{"location":"about/","title":"About","text":""},{"location":"about/#about","title":"About","text":"<p>Ozzy was initially developed by Mariana Moreira as a way to cope with her feeling of overwhelm when trying to process data from different simulation codes and designing complex analysis scripts for multidimensional data. Less of our time as physicists should be spent figuring out how to parse data into a convenient format and debugging the array manipulation bits of our code.</p> <p>This project can be extended to any simulation file format, and the hope is that it can prove useful to other plasma physicists.</p>"},{"location":"about/license/","title":"License","text":"<p>Copyright \u00a9 2024 Mariana Moreira - All Rights Reserved </p> <p>You may use, distribute and modify this code under the terms of the MIT License.</p> Full license text <p> MIT License</p> <p>Copyright (c) 2024 Mariana Moreira</p> <p>Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:</p> <p>The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.</p> <p>THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. </p>"},{"location":"about/license/#bundled-software-components","title":"Bundled software components","text":""},{"location":"about/license/#paul-tols-colour-schemes","title":"Paul Tol's colour schemes","text":"<p>Ozzy bundles Paul Tol's colour schemes definition, which is available under a \"3-clause BSD\" license. The qualitative colour scheme \"muted\" is used by default in <code>ozzy.plot</code>.</p>"},{"location":"about/license/#fonts","title":"Fonts","text":"<p>The plotting submodule of ozzy also bundles a few different fonts under the SIL Open Font License (OFL) Version 1.1., which is a free and open-source license. The full text of these licenses is included for each font in the fonts directory (<code>src/ozzy/fonts/</code>).</p> Font Design Copyright Crimson Pro Jacques Le Bailly Copyright \u00a9 2018 The Crimson Pro Project Authors Maitree Cadson Demak Copyright \u00a9 2015, Cadson Demak Noto Serif Copyright \u00a9 2022 The Noto Project Authors Roboto Serif Commercial Type, Greg Gazdowicz Copyright \u00a9 2020 The Roboto Serif Project Authors Source Serif 4 Frank Grie\u00dfhammer STIX Two Text Tiro Typeworks, Ross Mills, John Hudson, Paul Hanslow Copyright \u00a9 2001-2021 The STIX Fonts Project Authors, with Reserved Font Name \"TM Math\". STIX Fonts\u2122 is a trademark of The Institute of Electrical and Electronics Engineers, Inc."},{"location":"dev-guide/","title":"Index","text":""},{"location":"dev-guide/new-backend-modules/","title":"Submodules for each backend","text":""},{"location":"dev-guide/new-backend-modules/#submodules-for-each-backend","title":"Submodules for each backend","text":"<p>In order to open the output files from a given simulation code, an ozzy submodule for that code is required (in <code>src/ozzy/backends</code>). This submodule should contain instructions for parsing the data and the definition of format-specific methods (see Backend-specific methods).</p> <p>Each file format submodule must contain the following minimal quantities.</p>"},{"location":"dev-guide/new-backend-modules/#ozzy.backends.template_backend.general_file_endings","title":"<code>general_file_endings = []</code>  <code>module-attribute</code>","text":"<p>A list of file extensions to consider when reading files. These extensions are used to identify and filter out certain types of files when trying to find the data.</p> Example <p>For LCODE files: </p><pre><code>general_file_endings = [\"swp\", \"dat\", \"det\", \"bin\", \"bit\", \"pls\"]\n</code></pre><p></p>"},{"location":"dev-guide/new-backend-modules/#ozzy.backends.template_backend.general_regex_pattern","title":"<code>general_regex_pattern = ''</code>  <code>module-attribute</code>","text":"<p>A regular expression pattern used for matching file names or contents. The pattern is an empty string by default.</p> <p>Tip</p> <p>Use regex101.com to experiment with and debug regular expressions.</p> Example <p>For OSIRIS files: </p><pre><code>general_regex_pattern = r\"([\\w-]+)-(\\d{6})\\.(h5|hdf)\"\n</code></pre><p></p>"},{"location":"dev-guide/new-backend-modules/#ozzy.backends.template_backend.quants_ignore","title":"<code>quants_ignore = None</code>  <code>module-attribute</code>","text":"<p>A list of variable names to ignore when reading data. This is useful when the code saves a file containing axis data or other metadata only, and should therefore not be considered a quantity file. If <code>None</code>, no variables are ignored.</p> Example <p>For LCODE files: </p><pre><code>quants_ignore = [\"xi\"]\n</code></pre><p></p>"},{"location":"dev-guide/new-backend-modules/#ozzy.backends.template_backend.Methods","title":"<code>Methods</code>","text":"<p>Mixin class containing the definition of format-specific methods.</p>"},{"location":"dev-guide/new-backend-modules/#ozzy.backends.template_backend.read","title":"<code>read(files, **kwargs)</code>","text":"<p>Read a list of files and return a Dataset. If an <code>OSError</code> occurs during the reading process, a new empty Dataset should be created and returned.</p>"},{"location":"reference/","title":"Welcome to the ozzy Code Reference!","text":""},{"location":"reference/#welcome-to-the-ozzy-code-reference","title":"Welcome to the ozzy Code Reference!","text":"<ul> <li> <code>ozzy</code> (core functions)</li> <li> Data object methods</li> <li> Backends</li> <li> <code>ozzy.plot</code></li> <li> <code>ozzy.statistics</code></li> <li> <code>ozzy.fields</code></li> <li> <code>ozzy.utils</code></li> </ul>"},{"location":"reference/core/","title":"ozzy","text":""},{"location":"reference/core/#ozzy","title":"ozzy","text":"<p>Core functions of the ozzy library.</p> <p>This module contains the main entry points for working with ozzy, including functions to create new DataArray and Dataset objects, and to open data files of various types.</p> <p>The <code>open()</code> function is the primary way to load data into ozzy, and supports a variety of file types. The <code>open_series()</code> function can be used to load a series of files, and <code>open_compare()</code> can be used to compare data across multiple file types and runs.</p>"},{"location":"reference/core/#ozzy.core.DataArray","title":"DataArray","text":"<pre><code>DataArray(\n    *args, pic_data_type=None, data_origin=None, **kwargs\n)\n</code></pre> <p>Create a new DataArray object with added Ozzy functionality. See xarray.DataArray for more information on <code>*args</code> and <code>**kwargs</code>.</p> <p>Warning</p> <p>This function should be used instead of <code>xarray.DataArray()</code> to create a new DataArray object, since it sets attributes that enable access to ozzy-specific methods.</p> <p>Parameters:</p> Name Type Description Default <p>Positional arguments passed to xarray.DataArray.</p> <code>()</code> <code>str | None</code> <p>Type of data in the DataArray. Current options: <code>'grid'</code> (data defined on an n-dimensional grid, as a function of some coordinate(s)), or <code>'part'</code> (data defined on a particle-by-particle basis). If given, this overwrites the corresponding attribute in any data objects passed as positional arguments (*args).</p> <code>None</code> <code>str | None</code> <p>Type of simulation data. Current options: <code>'ozzy'</code>, <code>'osiris'</code>, or <code>'lcode'</code>.</p> <code>None</code> <p>Keyword arguments passed to xarray.DataArray.</p> <code>{}</code> <p>Returns:</p> Type Description <code>DataArray</code> <p>The newly created DataArray object.</p> <p>Examples:</p> Empty DataArray <pre><code>import ozzy as oz\nda = oz.DataArray()\nprint(da)\n# &lt;xarray.DataArray ()&gt; Size: 8B\n# array(nan)\n# Attributes:\n#     pic_data_type:  None\n#     data_origin:    None\nda.size, da.shape\n# (1, ())\n</code></pre> <p>A DataArray cannot be empty, so it is initialized as a NaN variable (zero array dimensions).</p> Dummy DataArray <pre><code>import ozzy as oz\nimport numpy as np\nda = oz.DataArray(np.random.rand(10,30), dims=['t','x'], coords={'x': np.linspace(-5,0,30)}, name='var1', pic_data_type='grid', data_origin='ozzy')\nda\n# &lt;xarray.DataArray 'var1' (t: 10, x: 30)&gt; Size: 2kB\n# array([[0.64317574, 0.24791049, 0.54208619, 0.27064002, 0.65152958,\n# ...\n#         0.28523593, 0.76475677, 0.86068012, 0.03214018, 0.55055121]])\n# Coordinates:\n# * x        (x) float64 240B -5.0 -4.828 -4.655 -4.483 ... -0.3448 -0.1724 0.0\n# Dimensions without coordinates: t\n# Attributes:\n#     pic_data_type:  grid\n#     data_origin:    ozzy\n</code></pre>"},{"location":"reference/core/#ozzy.core.DataArray(*args)","title":"<code>*args</code>","text":""},{"location":"reference/core/#ozzy.core.DataArray(pic_data_type)","title":"<code>pic_data_type</code>","text":""},{"location":"reference/core/#ozzy.core.DataArray(data_origin)","title":"<code>data_origin</code>","text":""},{"location":"reference/core/#ozzy.core.DataArray(**kwargs)","title":"<code>**kwargs</code>","text":""},{"location":"reference/core/#ozzy.core.Dataset","title":"Dataset","text":"<pre><code>Dataset(\n    *args, pic_data_type=None, data_origin=None, **kwargs\n)\n</code></pre> <p>Create a new Dataset object with added ozzy functionality. See xarray.Dataset for more information on <code>*args</code> and <code>**kwargs</code>.</p> <p>Warning</p> <p>This function should be used instead of <code>xarray.Dataset()</code> to create a new Dataset object, since it sets attributes that enable access to ozzy-specific methods.</p> <p>Parameters:</p> Name Type Description Default <p>Positional arguments passed to xarray.Dataset.</p> <code>()</code> <code>str | list[str] | None</code> <p>Type of data contained in the Dataset. Current options: <code>'grid'</code> (data defined on an n-dimensional grid, as a function of some coordinate(s)), or <code>'part'</code> (data defined on a particle-by-particle basis). If given, this overwrites the corresponding attribute in any data objects passed as positional arguments (*args).</p> <code>None</code> <code>str | list[str] | None</code> <p>Type of simulation data. Current options: <code>'ozzy'</code>, <code>'osiris'</code>, or <code>'lcode'</code>.</p> <code>None</code> <p>Keyword arguments passed to xarray.Dataset.</p> <code>{}</code> <p>Returns:</p> Type Description <code>Dataset</code> <p>The newly created Dataset object.</p> <p>Examples:</p> Empty Dataset <pre><code>import ozzy as oz\nds = oz.Dataset()\nds\n# &lt;xarray.Dataset&gt; Size: 0B\n# Dimensions:  ()\n# Data variables:\n#     *empty*\n# Attributes:\n#     pic_data_type:  None\n#     data_origin:    None\n</code></pre> Dummy Dataset <pre><code>import ozzy as oz\nimport numpy as np\nds = oz.Dataset({'var1': (['t','x'], np.random.rand(10,30))}, coords={'x': np.linspace(-5,0,30)}, pic_data_type='grid', data_origin='ozzy')\nds\n# &lt;xarray.Dataset&gt; Size: 3kB\n# Dimensions:  (t: 10, x: 30)\n# Coordinates:\n# * x        (x) float64 240B -5.0 -4.828 -4.655 -4.483 ... -0.3448 -0.1724 0.0\n# Dimensions without coordinates: t\n# Data variables:\n#     var1     (t, x) float64 2kB 0.9172 0.3752 0.1873 ... 0.5211 0.8016 0.335\n# Attributes:\n#     pic_data_type:  grid\n#     data_origin:    ozzy\n</code></pre>"},{"location":"reference/core/#ozzy.core.Dataset(*args)","title":"<code>*args</code>","text":""},{"location":"reference/core/#ozzy.core.Dataset(pic_data_type)","title":"<code>pic_data_type</code>","text":""},{"location":"reference/core/#ozzy.core.Dataset(data_origin)","title":"<code>data_origin</code>","text":""},{"location":"reference/core/#ozzy.core.Dataset(**kwargs)","title":"<code>**kwargs</code>","text":""},{"location":"reference/core/#ozzy.core.available_backends","title":"available_backends","text":"<pre><code>available_backends()\n</code></pre> <p>List available backend options for reading simulation data.</p> <p>Returns:</p> Type Description <code>list[str]</code> <p>Available backend names.</p> <p>Examples:</p> Show available file backends <pre><code>import ozzy as oz\nbackends = oz.available_backends()\nprint(backends)\n# ['osiris', 'lcode', 'ozzy']\n</code></pre>"},{"location":"reference/core/#ozzy.core.open","title":"open","text":"<pre><code>open(file_type, path, axes_lims=None, **kwargs)\n</code></pre> <p>Open a data file and return a data object (DataArray or Dataset).</p> <p>Parameters:</p> Name Type Description Default <code>str</code> <p>The type of data file to open. Current options: <code>'ozzy'</code>, <code>'osiris'</code>, or <code>'lcode'</code>.</p> required <code>str | list[str]</code> <p>The path to the data file(s) to open. Can be a single path or a list of paths. Paths can be absolute or relative, but cannot contain wildcards or glob patterns.</p> required <p>Additional keyword arguments to be passed to the backend-specific reader function.</p> <p>See available keyword arguments for each backend:</p> <ul> <li>LCODE</li> <li>OSIRIS</li> <li>ozzy</li> </ul> <code>{}</code> <p>Returns:</p> Type Description <code>Dataset | DataArray</code> <p>The Ozzy data object containing the data from the opened file(s).</p> <p>Examples:</p> Read Osiris field data <pre><code>import ozzy as oz\nds = oz.open('osiris', 'path/to/file/e1-000020.h5')\n</code></pre> Read LCODE field data <p>LCODE simulation files do not contain any axis information, so we must supply the simulation window size in order to define the axis coordinates (this is optional).</p> <pre><code>import ozzy as oz\nds = oz.open('lcode', 'path/to/file/ez02500.swp', axes_lims = {'x1': (-100,0.0), 'x2': (0.0, 6.0)})\n</code></pre>"},{"location":"reference/core/#ozzy.core.open(file_type)","title":"<code>file_type</code>","text":""},{"location":"reference/core/#ozzy.core.open(path)","title":"<code>path</code>","text":""},{"location":"reference/core/#ozzy.core.open(**kwargs)","title":"<code>**kwargs</code>","text":""},{"location":"reference/core/#ozzy.core.open_compare","title":"open_compare","text":"<pre><code>open_compare(\n    file_types,\n    path=os.getcwd(),\n    runs=\"*\",\n    quants=\"*\",\n    **kwargs\n)\n</code></pre> <p>Open and compare data files of different types and from different runs.</p> <p>Parameters:</p> Name Type Description Default <code>str | list[str]</code> <p>The type(s) of data files to open. Current options are: <code>'ozzy'</code>, <code>'osiris'</code>, or <code>'lcode'</code>.</p> required <code>str</code> <p>The path to the directory containing the run folders. Default is the current working directory.</p> <code>getcwd()</code> <code>str | list[str]</code> <p>A string or glob pattern to match the run folder names. Default is '*' to match all folders.</p> <code>'*'</code> <code>str | list[str]</code> <p>A string or glob pattern to match the quantity names. Default is '*' to match all quantities.</p> <code>'*'</code> <p>Additional keyword arguments to be passed to the backend-specific reader function.</p> <p>See available keyword arguments for each backend:</p> <ul> <li>LCODE</li> <li>OSIRIS</li> <li>ozzy</li> </ul> <code>{}</code> <p>Returns:</p> Type Description <code>DataFrame</code> <p>A DataFrame containing the data objects for each run and quantity, with runs as rows and quantities as columns.</p> <p>Examples:</p> Opening files across different folders <p>Let's say we have the following directory: </p><pre><code>.\n\u2514\u2500\u2500 parameter_scans/\n    \u251c\u2500\u2500 run_a/\n    \u2502   \u251c\u2500\u2500 e1-000000.h5\n    \u2502   \u251c\u2500\u2500 e1-000001.h5\n    \u2502   \u251c\u2500\u2500 e1-000002.h5\n    \u2502   \u251c\u2500\u2500 ...\n    \u2502   \u2514\u2500\u2500 e1-000100.h5\n    \u251c\u2500\u2500 run_b/\n    \u2502   \u251c\u2500\u2500 e1-000000.h5\n    \u2502   \u251c\u2500\u2500 e1-000001.h5\n    \u2502   \u251c\u2500\u2500 e1-000002.h5\n    \u2502   \u251c\u2500\u2500 ...\n    \u2502   \u2514\u2500\u2500 e1-000100.h5\n    \u2514\u2500\u2500 test_run/\n        \u2514\u2500\u2500 ...\n</code></pre><p></p> <p>We want to compare the simulations results for the longitudinal field from two different simulations, <code>run_a</code> and <code>run_b</code>.</p> <p></p><pre><code>import ozzy as oz\ndf = oz.open_compare('osiris', path='parameter_scans', runs='run_*', quants='e1')\ndf\n</code></pre> This function returns a pandas.DataFrame. Each dataset can be accessed with a standard Pandas lookup method like <code>.at</code>/<code>.iat</code> or <code>.loc</code>/<code>.iloc</code>: <pre><code>ds = df.at['run_b', 'e1']\n</code></pre><p></p> Opening files with two different backends <p>Let's say we have the following directory: </p><pre><code>/MySimulations/\n\u251c\u2500\u2500 OSIRIS/\n\u2502   \u2514\u2500\u2500 my_sim_1/\n\u2502       \u2514\u2500\u2500 MS/\n\u2502           \u2514\u2500\u2500 DENSITY/\n\u2502               \u2514\u2500\u2500 electrons/\n\u2502                   \u2514\u2500\u2500 charge/\n\u2502                       \u251c\u2500\u2500 charge-electrons-000000.h5\n\u2502                       \u251c\u2500\u2500 charge-electrons-000001.h5\n\u2502                       \u251c\u2500\u2500 charge-electrons-000002.h5\n\u2502                       \u2514\u2500\u2500 ...\n\u2514\u2500\u2500 LCODE/\n    \u2514\u2500\u2500 my_sim_2/\n        \u251c\u2500\u2500 ez00200.swp\n        \u251c\u2500\u2500 ez00400.swp\n        \u251c\u2500\u2500 ez00600.swp\n        \u2514\u2500\u2500 ...\n</code></pre> We can read two quantities produced by two different simulation codes:<p></p> <pre><code>import ozzy as oz\ndf = oz.open_compare(\n    [\"osiris\", \"lcode\"],\n    path='/MySimulations',\n    runs=[\"OSIRIS/my_sim_1\", \"LCODE/my_sim_2\"],\n    quants=[\"charge\", \"ez\"],\n)\n# ...\nprint(df)\n#                   charge-electrons    ez\n# OSIRIS/my_sim_1           [charge]    []\n# LCODE/my_sim_2                  []  [ez]\n</code></pre>"},{"location":"reference/core/#ozzy.core.open_compare(file_types)","title":"<code>file_types</code>","text":""},{"location":"reference/core/#ozzy.core.open_compare(path)","title":"<code>path</code>","text":""},{"location":"reference/core/#ozzy.core.open_compare(runs)","title":"<code>runs</code>","text":""},{"location":"reference/core/#ozzy.core.open_compare(quants)","title":"<code>quants</code>","text":""},{"location":"reference/core/#ozzy.core.open_compare(**kwargs)","title":"<code>**kwargs</code>","text":""},{"location":"reference/core/#ozzy.core.open_series","title":"open_series","text":"<pre><code>open_series(file_type, files, nfiles=None, **kwargs)\n</code></pre> <p>Open a series of data files and return a data object (DataArray or Dataset).</p> <p>Parameters:</p> Name Type Description Default <code>str</code> <p>The type of data files to open (currently: <code>'ozzy'</code>, <code>'osiris'</code>, or <code>'lcode'</code>).</p> required <code>str | list</code> <p>The path(s) to the data file(s) to open. Can be a single path or a list of paths. Paths can be absolute or relative, but cannot contain wildcards or glob patterns.</p> required <code>int</code> <p>The maximum number of files to open. If not provided, all files will be opened.</p> <code>None</code> <p>Additional keyword arguments to be passed to the backend-specific reader function.</p> <p>See available keyword arguments for each backend:</p> <ul> <li>LCODE</li> <li>OSIRIS</li> <li>ozzy</li> </ul> <code>{}</code> <p>Returns:</p> Type Description <code>DataArray | Dataset</code> <p>The Ozzy data object containing the data from the opened file(s).</p> <p>Examples:</p> Open time series of data <p>Let's say we are located in the following directory, which contains a time series of ozzy data in HDF5 format: </p><pre><code>.\n\u2514\u2500\u2500 my_data/\n    \u251c\u2500\u2500 Ez_0001.h5\n    \u251c\u2500\u2500 Ez_0002.h5\n    \u251c\u2500\u2500 Ez_0003.h5\n    \u251c\u2500\u2500 ...\n    \u2514\u2500\u2500 Ez_0050.h5\n</code></pre><p></p> <p>We want to open only the first three files.</p> <p></p><pre><code>import ozzy as oz\nds = oz.open_series('ozzy', 'my_data/Ez_*.h5', nfiles=3)\n</code></pre> The three files have been put together in a single dataset with a new time dimension.<p></p>"},{"location":"reference/core/#ozzy.core.open_series(file_type)","title":"<code>file_type</code>","text":""},{"location":"reference/core/#ozzy.core.open_series(files)","title":"<code>files</code>","text":""},{"location":"reference/core/#ozzy.core.open_series(nfiles)","title":"<code>nfiles</code>","text":""},{"location":"reference/core/#ozzy.core.open_series(**kwargs)","title":"<code>**kwargs</code>","text":""},{"location":"reference/fields/","title":"ozzy.fields","text":"<p>This submodule includes functions to analyze field data.</p>"},{"location":"reference/fields/#ozzy.fields.local_maxima_and_zero_crossings","title":"local_maxima_and_zero_crossings","text":"<pre><code>local_maxima_and_zero_crossings(\n    da,\n    comoving_var=\"x1_box\",\n    transv_var=\"x2\",\n    t_var=\"t\",\n    transv_range=None,\n    transv_irange=None,\n    transv_pos=None,\n    transv_ipos=None,\n    amplitude_mode=\"noisy\",\n    expected_wvl=2 * np.pi,\n    amplitude_max_for=\"negative_charge\",\n)\n</code></pre> <p>Find local field maxima and zero crossings in a DataArray.</p> <p>This function analyzes a field (typically an electric field) to identify local maxima and zero crossings along a specified dimension. It can process the data in different ways depending on whether the field data is noisy or smooth.</p> <p>Parameters:</p> Name Type Description Default <code>DataArray</code> <p>The data array containing the field to analyze.</p> required <code>str</code> <p>The name of the coordinate representing the comoving dimension.</p> <code>'x1_box'</code> <code>str</code> <p>The name of the coordinate representing the transverse dimension.</p> <code>'x2'</code> <code>str</code> <p>The name of the coordinate representing time.</p> <code>'t'</code> <code>tuple | list | ndarray</code> <p>Range of transverse positions to average over, specified as (min, max).</p> <code>None</code> <code>tuple | list | ndarray</code> <p>Range of transverse indices to average over, specified as (min, max).</p> <code>None</code> <code>float</code> <p>Specific transverse position to analyze.</p> <code>None</code> <code>int</code> <p>Specific transverse index to analyze.</p> <code>None</code> <code>str</code> <p>Method for handling amplitude analysis. Must be either <code>'noisy'</code> or <code>'smooth'</code>. For <code>'noisy'</code> data, a moving window average is applied before analysis.</p> <code>'noisy'</code> <code>float</code> <p>Expected wavelength of the oscillations in the field in normalized units (i.e. \\(k_p^{-1}\\)) used for window sizing.</p> <code>2 * pi</code> <code>str</code> <p>Specifies which charge sign to find the maximum accelerating amplitude for. Must be either <code>'negative_charge'</code> or <code>'positive_charge'</code>.</p> <code>'negative_charge'</code> <p>Returns:</p> Type Description <code>tuple</code> <p>A tuple containing two xarray.Dataset objects:</p> <ul> <li> <p>First element: Dataset with local maxima information</p> </li> <li> <p>Second element: Dataset with zero crossing information</p> </li> </ul> <p>Raises:</p> Type Description <code>ValueError</code> <p>If required coordinates are missing from the DataArray.</p> <p>If invalid options are provided for <code>amplitude_mode</code> or <code>amplitude_max_for</code>.</p> <p>If invalid ranges or positions are specified for transverse selection.</p> Notes <p>The function processes data differently based on the <code>amplitude_mode</code>:</p> <ul> <li> <p>For <code>'noisy'</code> data: Applies a moving window average before analysis</p> </li> <li> <p>For <code>'smooth'</code> data: Analyzes the raw data directly</p> </li> </ul> <p>Examples:</p> Basic usage with default parameters <pre><code>import xarray as xr\nimport numpy as np\n\n# Create a sample dataset with a sinusoidal field\nx = np.linspace(0, 10*np.pi, 1000)\ny = np.linspace(-5, 5, 20)\nt = np.array([0.0, 1.0, 2.0])\n\n# Create field data with some noise\nfield = np.zeros((len(t), len(y), len(x)))\nfor i in range(len(t)):\n    for j in range(len(y)):\n        field[i, j, :] = np.sin(x) + 0.1*np.random.randn(len(x))\n\n# Create DataArray\nda = xr.DataArray(\n    field,\n    coords={'t': t, 'x2': y, 'x1_box': x},\n    dims=['t', 'x2', 'x1_box']\n)\n\n# Find zero crossings and maxima\nmaxima, zeros = local_maxima_and_zero_crossings(da)\n\n# The returned datasets contain information about zero crossings and maxima\n# zeros contains 'zero_crossings' coordinate\n# maxima contains 'max_locs' and 'max_vals' coordinates\n</code></pre> Using custom parameters for a smooth field <pre><code>import xarray as xr\nimport numpy as np\n\n# Create a sample dataset with a clean sinusoidal field\nx = np.linspace(0, 10*np.pi, 1000)\ny = np.linspace(-5, 5, 20)\nt = np.array([0.0, 1.0, 2.0])\n\n# Create clean field data\nfield = np.zeros((len(t), len(y), len(x)))\nfor i in range(len(t)):\n    for j in range(len(y)):\n        field[i, j, :] = np.sin(x)\n\n# Create DataArray\nda = xr.DataArray(\n    field,\n    coords={'t': t, 'x2': y, 'x1_box': x},\n    dims=['t', 'x2', 'x1_box']\n)\n\n# Find zero crossings and maxima with custom parameters\nmaxima, zeros = local_maxima_and_zero_crossings(\n    da,\n    comoving_var=\"x1_box\",\n    transv_range=(-2, 2),  # Average over this transverse range\n    amplitude_mode=\"smooth\",  # Use smooth mode for clean data\n    amplitude_max_for=\"positive_charge\"  # Find positive field amplitude maximum\n)\n</code></pre>"},{"location":"reference/fields/#ozzy.fields.local_maxima_and_zero_crossings(da)","title":"<code>da</code>","text":""},{"location":"reference/fields/#ozzy.fields.local_maxima_and_zero_crossings(comoving_var)","title":"<code>comoving_var</code>","text":""},{"location":"reference/fields/#ozzy.fields.local_maxima_and_zero_crossings(transv_var)","title":"<code>transv_var</code>","text":""},{"location":"reference/fields/#ozzy.fields.local_maxima_and_zero_crossings(t_var)","title":"<code>t_var</code>","text":""},{"location":"reference/fields/#ozzy.fields.local_maxima_and_zero_crossings(transv_range)","title":"<code>transv_range</code>","text":""},{"location":"reference/fields/#ozzy.fields.local_maxima_and_zero_crossings(transv_irange)","title":"<code>transv_irange</code>","text":""},{"location":"reference/fields/#ozzy.fields.local_maxima_and_zero_crossings(transv_pos)","title":"<code>transv_pos</code>","text":""},{"location":"reference/fields/#ozzy.fields.local_maxima_and_zero_crossings(transv_ipos)","title":"<code>transv_ipos</code>","text":""},{"location":"reference/fields/#ozzy.fields.local_maxima_and_zero_crossings(amplitude_mode)","title":"<code>amplitude_mode</code>","text":""},{"location":"reference/fields/#ozzy.fields.local_maxima_and_zero_crossings(expected_wvl)","title":"<code>expected_wvl</code>","text":""},{"location":"reference/fields/#ozzy.fields.local_maxima_and_zero_crossings(amplitude_max_for)","title":"<code>amplitude_max_for</code>","text":""},{"location":"reference/fields/#ozzy.fields.vphi_from_fit","title":"vphi_from_fit","text":"<pre><code>vphi_from_fit(\n    da,\n    x_zero,\n    x_var=\"x1_box\",\n    t_var=\"t\",\n    window_len=2.5,\n    k=1.0,\n    boundary=\"trim\",\n    quasistatic_fixed_z=False,\n)\n</code></pre> <p>Measure the phase (\\(\\phi\\)) and phase velocity (\\(v_\\phi\\)) from stacked lineouts of a wave (waterfall data) by fitting a sinusoidal function to blocks of data.</p> <p>Parameters:</p> Name Type Description Default <code>DataArray</code> <p>The input xarray.DataArray containing the data to be analyzed.</p> <p>The data should be two-dimensional: time or propagation distance along one dimension, and a longitudinal coordinate along the other dimension.</p> required <code>float</code> <p>Position along the longitudinal coordinate where the sine should be considered to start, and with respect to which the phase will be measured. For example, a seed position.</p> required required <code>str</code> <p>The name of the spatial dimension along which to perform the fit. Default is <code>'x1'</code>.</p> <code>'x1_box'</code> <code>str</code> <p>The name of the time or propagation dimension. Default is <code>'t'</code>.</p> <code>'t'</code> <code>float</code> <p>The length of the window (in units of the plasma wavelength) over which to perform the fit. Default is <code>2.5</code>.</p> <code>2.5</code> <code>float | str</code> <p>The wavenumber to use in the definition of the window length. If <code>'fft'</code>, the wavenumber will be calculated from the FFT of the data. Default is <code>1.0</code>.</p> <code>1.0</code> <code>str</code> <p>How to handle boundaries when coarsening the data into blocks. One of <code>'trim'</code>, <code>'pad'</code>, or <code>'drop'</code>. See xarray.DataArray.coarsen.</p> <code>'trim'</code> <code>bool</code> <p>If True, the phase velocity is calculated assuming a quasistatic approximation with a fixed z-dimension. Default is False.</p> <code>False</code> <p>Returns:</p> Type Description <code>Dataset</code> <p>A dataset containing the calculated phase velocity (<code>'vphi'</code>), phase (<code>'phi'</code>), and phase error (<code>'phi_err'</code>).</p>"},{"location":"reference/fields/#ozzy.fields.vphi_from_fit(da)","title":"<code>da</code>","text":""},{"location":"reference/fields/#ozzy.fields.vphi_from_fit(x_zero)","title":"<code>x_zero</code>","text":""},{"location":"reference/fields/#ozzy.fields.vphi_from_fit(x)","title":"<code>x</code>","text":""},{"location":"reference/fields/#ozzy.fields.vphi_from_fit(x_var)","title":"<code>x_var</code>","text":""},{"location":"reference/fields/#ozzy.fields.vphi_from_fit(t_var)","title":"<code>t_var</code>","text":""},{"location":"reference/fields/#ozzy.fields.vphi_from_fit(window_len)","title":"<code>window_len</code>","text":""},{"location":"reference/fields/#ozzy.fields.vphi_from_fit(k)","title":"<code>k</code>","text":""},{"location":"reference/fields/#ozzy.fields.vphi_from_fit(boundary)","title":"<code>boundary</code>","text":""},{"location":"reference/fields/#ozzy.fields.vphi_from_fit(quasistatic_fixed_z)","title":"<code>quasistatic_fixed_z</code>","text":""},{"location":"reference/plot/","title":"ozzy.plot","text":"<p>In order to set ozzy's aesthetic options as defaults, and to have access to its color maps, color schemes and fonts, the plotting submodule must be imported:</p> <pre><code>import ozzy.plot as oplt\n</code></pre>"},{"location":"reference/plot/#defaults","title":"Defaults","text":"<p>The default plotting options loaded as matplotlib <code>rcParams</code> by ozzy can be printed with:</p> <pre><code>import ozzy.plot as oplt\nprint(oplt.ozparams)\n</code></pre> <p>The remaining defaults are:</p> Defaults Curve color scheme <code>'tol.muted'</code> Sequential colormap <code>'cmc.lipari'</code> Diverging colormap <code>'cmc.vik'</code> Font Noto Serif"},{"location":"reference/plot/#functions","title":"Functions","text":""},{"location":"reference/plot/#ozzy.plot.hist","title":"hist","text":"<pre><code>hist(\n    do,\n    x=None,\n    y=None,\n    w_var=\"q\",\n    bins=\"auto\",\n    cmap=\"cmc.bamako\",\n    cbar=False,\n    **kwargs\n)\n</code></pre> <p>Create a weighted histogram plot using <code>seaborn.histplot</code>.</p> <p>Parameters:</p> Name Type Description Default <code>Dataset | DataArray</code> <p>Input Dataset or DataArray to plot</p> required <code>str | None</code> <p>Variable name for x-axis</p> <code>None</code> <code>str | None</code> <p>Variable name for y-axis</p> <code>None</code> <code>str | None</code> <p>Variable name to use as weights</p> <code>'q'</code> <code>str | int | Iterable</code> <p>Generic bin parameter passed to <code>seaborn.histplot</code>. It can be <code>'auto'</code>, the number of bins, or the breaks of the bins. Defaults to <code>200</code> for weighted data or to an automatically calculated number for unweighted data.</p> <code>'auto'</code> <code>str | None</code> <p>Colormap name. Uses <code>'cmc.bamako'</code> or the <code>ozzy.plot</code> sequential default</p> <code>'cmc.bamako'</code> <code>bool</code> <p>Whether to display colorbar</p> <code>False</code> <p>Additional keyword arguments passed to <code>seaborn.histplot()</code></p> <code>{}</code> <p>Returns:</p> Type Description <code>Axes</code> <p>The plot axes object</p> <p>Examples:</p> Basic histogram <pre><code>import ozzy as oz\nimport ozzy.plot as oplt\nds = oz.Dataset(...)\nax = oplt.hist(ds, x='p2')\n</code></pre> 2D histogram with colorbar <pre><code>import ozzy as oz\nimport ozzy.plot as oplt\nds = oz.Dataset(...)\nax = oplt.hist(ds, x='x2', y='p2', cbar=True)\n</code></pre>"},{"location":"reference/plot/#ozzy.plot.hist(do)","title":"<code>do</code>","text":""},{"location":"reference/plot/#ozzy.plot.hist(x)","title":"<code>x</code>","text":""},{"location":"reference/plot/#ozzy.plot.hist(y)","title":"<code>y</code>","text":""},{"location":"reference/plot/#ozzy.plot.hist(w_var)","title":"<code>w_var</code>","text":""},{"location":"reference/plot/#ozzy.plot.hist(bins)","title":"<code>bins</code>","text":""},{"location":"reference/plot/#ozzy.plot.hist(cmap)","title":"<code>cmap</code>","text":""},{"location":"reference/plot/#ozzy.plot.hist(cbar)","title":"<code>cbar</code>","text":""},{"location":"reference/plot/#ozzy.plot.hist(**kwargs)","title":"<code>**kwargs</code>","text":""},{"location":"reference/plot/#ozzy.plot.hist_proj","title":"hist_proj","text":"<pre><code>hist_proj(\n    do,\n    x,\n    y,\n    w_var=\"q\",\n    bins=\"auto\",\n    cmap=\"cmc.bamako\",\n    space=0,\n    refline=False,\n    refline_kwargs={\n        \"x\": 0,\n        \"y\": 0,\n        \"linewidth\": 1.0,\n        \"alpha\": 0.5,\n    },\n    **kwargs\n)\n</code></pre> <p>Create a 2D histogram plot with projected distributions using <code>seaborn.jointplot(kind=\"hist\")</code>.</p> <p>Parameters:</p> Name Type Description Default <code>Dataset | DataArray</code> <p>Input Dataset or DataArray to plot</p> required <code>str</code> <p>Variable name for x-axis</p> required <code>str</code> <p>Variable name for y-axis</p> required <code>str | None</code> <p>Variable name to use as weights</p> <code>'q'</code> <code>str | int | Iterable</code> <p>Generic bin parameter passed to <code>seaborn.histplot</code>. It can be <code>'auto'</code>, the number of bins, or the breaks of the bins. Defaults to <code>200</code> for weighted data or to an automatically calculated number for unweighted data.</p> <code>'auto'</code> <code>str | None</code> <p>Colormap name. Uses <code>'cmc.bamako'</code> or the <code>ozzy.plot</code> sequential default</p> <code>'cmc.bamako'</code> <code>float</code> <p>Space between 2D plot and marginal projection plots</p> <code>0</code> <code>bool</code> <p>Whether to add reference lines (see <code>seaborn.JointGrid.refline</code>)</p> <code>False</code> <code>dict</code> <p>Keyword arguments for reference lines (see <code>seaborn.JointGrid.refline</code>)</p> <code>{'x': 0, 'y': 0, 'linewidth': 1.0, 'alpha': 0.5}</code> <p>Additional keyword arguments passed to <code>seaborn.jointplot()</code></p> <code>{}</code> <p>Returns:</p> Type Description <code>JointGrid</code> <p>The joint grid plot object</p> <p>Examples:</p> 2D histogram with projected distributions <pre><code>import ozzy as oz\nimport ozzy.plot as oplt\nds = oz.Dataset(...)\njg = oplt.hist_proj(ds, x='x2', y='p2')\n</code></pre> 2D histogram with projected distributions and reference lines <pre><code>import ozzy as oz\nimport ozzy.plot as oplt\nds = oz.Dataset(...)\njg = oplt.hist_proj(ds, x='x2', y='p2',\n                    refline=True,\n                    refline_kwargs={'x': 0, 'y': 0})\n</code></pre>"},{"location":"reference/plot/#ozzy.plot.hist_proj(do)","title":"<code>do</code>","text":""},{"location":"reference/plot/#ozzy.plot.hist_proj(x)","title":"<code>x</code>","text":""},{"location":"reference/plot/#ozzy.plot.hist_proj(y)","title":"<code>y</code>","text":""},{"location":"reference/plot/#ozzy.plot.hist_proj(w_var)","title":"<code>w_var</code>","text":""},{"location":"reference/plot/#ozzy.plot.hist_proj(bins)","title":"<code>bins</code>","text":""},{"location":"reference/plot/#ozzy.plot.hist_proj(cmap)","title":"<code>cmap</code>","text":""},{"location":"reference/plot/#ozzy.plot.hist_proj(space)","title":"<code>space</code>","text":""},{"location":"reference/plot/#ozzy.plot.hist_proj(refline)","title":"<code>refline</code>","text":""},{"location":"reference/plot/#ozzy.plot.hist_proj(refline_kwargs)","title":"<code>refline_kwargs</code>","text":""},{"location":"reference/plot/#ozzy.plot.hist_proj(**kwargs)","title":"<code>**kwargs</code>","text":""},{"location":"reference/plot/#ozzy.plot.imovie","title":"imovie","text":"<pre><code>imovie(\n    da,\n    t_var=\"t\",\n    clim=\"first\",\n    colormap=None,\n    widget_location=\"bottom\",\n    **kwargs\n)\n</code></pre> <p>Creates an interactive movie/animation plot from a DataArray using HoloViews.</p> <p>Parameters:</p> Name Type Description Default <code>DataArray</code> <p>Input data array to animate.</p> required <code>str</code> <p>Name of the time coordinate in the DataArray.</p> <code>'t'</code> <code>str | tuple of float</code> <p>Color limits specification. Can be: - <code>\"first\"</code>: Use min/max of first time step - <code>\"global\"</code>: Use global min/max across all time steps - <code>None</code>: Color scale changes at every time step - tuple of (min, max) values</p> <code>'first'</code> <code>str</code> <p>Name of colormap to use. If <code>None</code>, automatically selects: - <code>\"cmc.lipari\"</code> for single-signed data - <code>\"cmc.vik\"</code> for data crossing zero</p> <code>None</code> <code>str</code> <p>Location of the time selection widget.</p> <code>'bottom'</code> <code>dict</code> <p>Additional keyword arguments passed to <code>hvplot</code>.</p> <code>{}</code> <p>Returns:</p> Type Description <code>HoloMap</code> <p>Interactive HoloViews plot object.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If specified time variable is not found in coordinates. If <code>clim</code> is invalid type or wrong length.</p> <p>Examples:</p> Basic usage with default settings <pre><code>import ozzy as oz\nimport ozzy.plot as oplt\nimport numpy as np\n\n# Create sample data\ntime = np.arange(10)\ndata = np.random.rand(10, 20, 30)\nda = oz.DataArray(data, coords={'t': time, 'y': range(20), 'x': range(30)})\n\n# Create interactive plot\noplt.imovie(da)\n</code></pre> Custom time coordinate and color limits <pre><code>... # see example above\n\n# Create data with custom time coordinate\nda = oz.DataArray(data, coords={'time': time, 'y': range(20), 'x': range(30)})\n\n# Plot with custom settings\noplt.imovie(da, t_var='time', clim=(-1, 1), colormap='cmc.lisbon')\n</code></pre>"},{"location":"reference/plot/#ozzy.plot.imovie(da)","title":"<code>da</code>","text":""},{"location":"reference/plot/#ozzy.plot.imovie(t_var)","title":"<code>t_var</code>","text":""},{"location":"reference/plot/#ozzy.plot.imovie(clim)","title":"<code>clim</code>","text":""},{"location":"reference/plot/#ozzy.plot.imovie(colormap)","title":"<code>colormap</code>","text":""},{"location":"reference/plot/#ozzy.plot.imovie(widget_location)","title":"<code>widget_location</code>","text":""},{"location":"reference/plot/#ozzy.plot.imovie(**kwargs)","title":"<code>**kwargs</code>","text":""},{"location":"reference/plot/#ozzy.plot.movie","title":"movie","text":"<pre><code>movie(\n    fig,\n    plot_objs,\n    filename,\n    fps=5,\n    dpi=300,\n    t_range=None,\n    xlim=None,\n    ylim=None,\n    clim=None,\n    clim_fixed=True,\n    plot_func=None,\n    writer=\"ffmpeg\",\n    **kwargs\n)\n</code></pre> <p>Create an animation from matplotlib figure objects.</p> <p>Parameters:</p> Name Type Description Default <code>Figure</code> <p>The matplotlib Figure object to animate.</p> required <code>dict[Artist, tuple[DataArray, str]] | dict[Artist, DataArray]</code> <p>A dictionary mapping matplotlib Artist objects to either tuples containing a DataArray and the name of its time coordinate, or to a DataArray (where the time coordinate is assumed to be <code>'t'</code>).</p> required <code>str</code> <p>The output file name or path for the animation. If the path doesn't exist, missing folders will be created.</p> required <code>int</code> <p>Frames per second for the animation.</p> <code>5</code> <code>int</code> <p>Dots-per-inch resolution for the output.</p> <code>300</code> <code>tuple[float, float] | None</code> <p>The time range for the animation. If <code>None</code>, the full time range of the data will be used.</p> <code>None</code> <code>tuple[float, float] | None | dict[Artist, tuple[float, float]]</code> <p>The horizontal axis limits. Can be a tuple, <code>None</code>, or a dictionary mapping Artists to their respective limits.</p> <code>None</code> <code>tuple[float, float] | None | dict[Artist, tuple[float, float]]</code> <p>The vertical axis limits. Can be a tuple, <code>None</code>, or a dictionary mapping Artists to their respective limits.</p> <code>None</code> <code>tuple[float, float] | None | dict[Artist, tuple[float, float]]</code> <p>The color scale limits. Can be a tuple, <code>None</code>, or a dictionary mapping Artists to their respective limits.</p> <code>None</code> <code>bool</code> <p>If <code>False</code>, color scale limits vary for each time step.</p> <code>True</code> <code>Callable | dict[Artist, Callable] | None</code> <p>A function or dictionary of functions to customize the plot at each time step. Each function must take 5 arguments in this order: <code>ax</code> (matplotlib Axes), <code>imo</code> (matplotlib Artist), <code>da</code> (DataArray), <code>t_var</code> (str), <code>t_val</code> (float), and return None. The function overrides axis limits.</p> <code>None</code> <code>str</code> <p>The <code>matplotlib</code> animation writer to use. Options are <code>'ffmpeg'</code>, <code>'pillow'</code>, <code>'html'</code>, <code>'imagemagick'</code>, and <code>'frames_png'</code>. When <code>'frames_png'</code> is selected, no writer is used and the animation frames are saved to a folder in PNG format.</p> <p>Info</p> <p>The FFMpeg library must be installed on the system in order to use matplotlib's FFMpeg writer.</p> <code>'ffmpeg'</code> <p>Additional keyword arguments to pass to the <code>matplotlib</code> animation writer.</p> <p>Note</p> <p>For <code>writer='ffmpeg'</code>, a constant rate factor of 18 is set by default via <code>extra_args=['-crf', '18']</code>. See FFMpegWriter.</p> <code>{}</code> <p>Returns:</p> Type Description <code>None</code> <p>Examples:</p> Basic usage with a single plot object <pre><code>import matplotlib.pyplot as plt\nimport numpy as np\n\nimport ozzy as oz\nimport ozzy.plot as oplt\n\ntime = np.arange(0, 10, 0.1)\nx = np.arange(-20, 0, 0.2)\nX, T = np.meshgrid(x, time)\ndata = np.sin(X - 0.5 * T)\nda = oz.DataArray(\n    data, coords={\"time\": time, \"x\": x}, dims=[\"time\", \"x\"], pic_data_type=\"grid\"\n)\n\n# Create a figure and plot\nfig, ax = plt.subplots()\nline = da.isel(time=0).plot()\n\n# Create the movie\noplt.movie(fig, {line[0]: (da, \"time\")}, \"sine_wave.mp4\")\n# This will create an animation of a sine wave in 'sine_wave.mp4'\n</code></pre> Using multiple plot objects and custom limits <pre><code>import matplotlib.pyplot as plt\nimport numpy as np\n\nimport ozzy as oz\nimport ozzy.plot as oplt\n\ntime = np.arange(0, 10, 0.1)\nx = np.arange(-20, 0, 0.2)\nX, T = np.meshgrid(x, time)\ndata1 = np.sin(X - 0.5 * T)\ndata2 = np.cos(X - 0.5 * T)\nda1 = oz.DataArray(\n    data1, coords={\"time\": time, \"x\": x}, dims=[\"time\", \"x\"], pic_data_type=\"grid\"\n)\nda2 = oz.DataArray(\n    data2, coords={\"time\": time, \"x\": x}, dims=[\"time\", \"x\"], pic_data_type=\"grid\"\n)\n\n# Create a figure with two subplots\nfig, (ax1, ax2) = plt.subplots(2, 1)\n(line1,) = da1.isel(time=0).plot(ax=ax1)\n(line2,) = da2.isel(time=0).plot(ax=ax2)\n\n# Create the movie with custom limits\noplt.movie(\n    fig,\n    {line1: (da1, \"time\"), line2: (da2, \"time\")},\n    \"trig_functions.mp4\",\n    xlim={line1: (-5, 0), line2: (-20, -5)},\n    ylim=(-1.5, 1.5),\n    fps=10,\n)\n# This will create an animation of sine and cosine waves\n# with different x-axis limits for each subplot\n</code></pre>"},{"location":"reference/plot/#ozzy.plot.movie(fig)","title":"<code>fig</code>","text":""},{"location":"reference/plot/#ozzy.plot.movie(plot_objs)","title":"<code>plot_objs</code>","text":""},{"location":"reference/plot/#ozzy.plot.movie(filename)","title":"<code>filename</code>","text":""},{"location":"reference/plot/#ozzy.plot.movie(fps)","title":"<code>fps</code>","text":""},{"location":"reference/plot/#ozzy.plot.movie(dpi)","title":"<code>dpi</code>","text":""},{"location":"reference/plot/#ozzy.plot.movie(t_range)","title":"<code>t_range</code>","text":""},{"location":"reference/plot/#ozzy.plot.movie(xlim)","title":"<code>xlim</code>","text":""},{"location":"reference/plot/#ozzy.plot.movie(ylim)","title":"<code>ylim</code>","text":""},{"location":"reference/plot/#ozzy.plot.movie(clim)","title":"<code>clim</code>","text":""},{"location":"reference/plot/#ozzy.plot.movie(clim_fixed)","title":"<code>clim_fixed</code>","text":""},{"location":"reference/plot/#ozzy.plot.movie(plot_func)","title":"<code>plot_func</code>","text":""},{"location":"reference/plot/#ozzy.plot.movie(writer)","title":"<code>writer</code>","text":""},{"location":"reference/plot/#ozzy.plot.movie(**kwargs)","title":"<code>**kwargs</code>","text":""},{"location":"reference/plot/#ozzy.plot.set_cmap","title":"set_cmap","text":"<pre><code>set_cmap(\n    general=None,\n    qualitative=None,\n    diverging=None,\n    sequential=None,\n)\n</code></pre> <p>Set the default colormaps for various types of plots.</p> <p>Parameters:</p> Name Type Description Default <code>str</code> <p>The colormap to use for general plots.</p> <code>None</code> <code>str | list[str]</code> <p>The colormap or list of colors to use for qualitative plots (e.g., line plots).</p> <code>None</code> <code>str</code> <p>The colormap to use for diverging plots.</p> <code>None</code> <code>str</code> <p>The colormap to use for sequential plots.</p> <code>None</code> <p>Examples:</p> Set general colormap to viridis <pre><code>import ozzy.plot as oplt\noplt.set_cmap(general='viridis')\n</code></pre> Set diverging and sequential colormaps separately <pre><code>import ozzy.plot as oplt\noplt.set_cmap(diverging='cmc.lisbon', sequential='tol.iridescent')\n</code></pre> Set qualitative colormap to Paul Tol's Bright color scheme <pre><code>import ozzy.plot as oplt\noplt.set_cmap(qualitative='tol.bright')\n</code></pre>"},{"location":"reference/plot/#ozzy.plot.set_cmap(general)","title":"<code>general</code>","text":""},{"location":"reference/plot/#ozzy.plot.set_cmap(qualitative)","title":"<code>qualitative</code>","text":""},{"location":"reference/plot/#ozzy.plot.set_cmap(diverging)","title":"<code>diverging</code>","text":""},{"location":"reference/plot/#ozzy.plot.set_cmap(sequential)","title":"<code>sequential</code>","text":""},{"location":"reference/plot/#ozzy.plot.set_font","title":"set_font","text":"<pre><code>set_font(font)\n</code></pre> <p>Set the font family for all text in the plots.</p> <p>Note</p> <p>If you want all text in the plot to be rendered in LaTeX math font, as opposed to only the text surrounded by <code>$...$</code>, use the following commands:</p> <p></p><pre><code>import ozzy.plot as oplt\noplt.plt.rcParams['text.usetex'] = True\n</code></pre> or <pre><code>import ozzy.plot as oplt\nimport matplotlib.pyplot as plt\nplt.rcParams[\"text.usetex\"] = True\n</code></pre><p></p> <p>Parameters:</p> Name Type Description Default <code>str</code> <p>The name of the font family to use. The font must be installed on the system and recognized by <code>matplotlib.font_manager.get_font_names()</code>.</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>If the specified <code>font</code> is not found in the list of available font names.</p> <p>Examples:</p> Set font to DejaVu Sans <pre><code>import ozzy.plot as oplt\noplt.set_font('DejaVu Sans')\n</code></pre> Attempt to set an invalid font <pre><code>import ozzy.plot as oplt\noplt.set_font('InvalidFontName')\n# ValueError: Couldn't find font\n</code></pre>"},{"location":"reference/plot/#ozzy.plot.set_font(font)","title":"<code>font</code>","text":""},{"location":"reference/plot/#ozzy.plot.show_cmaps","title":"show_cmaps","text":"<pre><code>show_cmaps(library='all', category='all')\n</code></pre> <p>Display available colormaps from different libraries and categories.</p> <p>Parameters:</p> Name Type Description Default <code>str | list[str]</code> <p>The library or libraries to display colormaps from. Options are <code>'mpl'</code> (Matplotlib), <code>'cmc'</code> (Scientific colour maps by F. Crameri), <code>'tol'</code> (Paul Tol's colormaps), and <code>'all'</code>.</p> <code>'all'</code> <code>str | list[str]</code> <p>The category or categories of colormaps to display. Options are <code>'sequential'</code>, <code>'diverging'</code>, <code>'qualitative'</code>, <code>'cyclical'</code>, and <code>'all'</code>.</p> <code>'all'</code> <p>Examples:</p> Show all available colormaps <pre><code>import ozzy.plot as oplt\noplt.show_cmaps()\n</code></pre> Show sequential colormaps from Matplotlib <pre><code>import ozzy.plot as oplt\noplt.show_cmaps(library='mpl', category='sequential')\n</code></pre> Show diverging colormaps from Paul Tol and Scientific colour maps <pre><code>import ozzy.plot as oplt\noplt.show_cmaps(library=['tol', 'cmc'], category='diverging')\n</code></pre>"},{"location":"reference/plot/#ozzy.plot.show_cmaps(library)","title":"<code>library</code>","text":""},{"location":"reference/plot/#ozzy.plot.show_cmaps(category)","title":"<code>category</code>","text":""},{"location":"reference/plot/#ozzy.plot.show_fonts","title":"show_fonts","text":"<pre><code>show_fonts(samples=False, fontsize=18)\n</code></pre> <p>Display a list of fonts bundled with ozzy and other fonts available on the system.</p> <p>Parameters:</p> Name Type Description Default <code>bool</code> <p>If <code>True</code>, display font samples in addition to the font names.</p> <p>Warning</p> <p>The font samples are rendered as an HTML object (only works with Jupyter).</p> <code>False</code> <code>float</code> <p>The font size to use for displaying font samples.</p> <code>18</code> <p>Examples:</p> Show font names only <pre><code>import ozzy.plot as oplt\noplt.show_fonts()\n</code></pre> Show font names and samples <pre><code>import ozzy.plot as oplt\noplt.show_fonts(samples=True)\n</code></pre>"},{"location":"reference/plot/#ozzy.plot.show_fonts(samples)","title":"<code>samples</code>","text":""},{"location":"reference/plot/#ozzy.plot.show_fonts(fontsize)","title":"<code>fontsize</code>","text":""},{"location":"reference/statistics/","title":"ozzy.statistics","text":"<p>The statistics submodule encompasses functions that process particle data or otherwise synthesize data into lower-dimensional measures. A classic example is getting the centroid (mean transverse position) of a particle distribution.</p>"},{"location":"reference/statistics/#ozzy.statistics.charge_in_field_quadrants","title":"charge_in_field_quadrants","text":"<pre><code>charge_in_field_quadrants(\n    raw_ds,\n    fields_ds,\n    t_var=\"t\",\n    w_var=\"q\",\n    n0=None,\n    xi_var=None,\n)\n</code></pre> <p>Calculate the amount of charge in different quadrants of the \"field space\". By quadrants we mean the four possible combinations of positive/negative longitudinal fields and positive/negative transverse fields.</p> <p>Parameters:</p> Name Type Description Default <code>Dataset</code> <p>Dataset containing particle data.</p> required <code>Dataset</code> <p>Dataset containing field data.</p> <p>Warning</p> <p>This function expects the <code>fields_ds</code> argument to be a dataset containing two variables, one of which corresponds to a longitudinal field/force and the other to a transverse field/force.</p> required <code>str</code> <p>Name of the time dimension in the input datasets. Default is <code>'t'</code>.</p> <code>'t'</code> <code>str</code> <p>Name of the variable representing particle weights or particle charge in <code>raw_ds</code>. Default is <code>'q'</code>.</p> <code>'q'</code> <code>float | None</code> <p>Reference plasma density value, in \\(\\mathrm{cm}^{-3}\\). If provided, the charge is converted to physical units. Default is None.</p> <code>None</code> <code>str | None</code> <p>Name of the variable representing the longitudinal axis. Required if <code>n0</code> is provided.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>charge_ds</code> <code>Dataset</code> <p>Dataset containing the charge in different quadrants of the \"field space\".</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the input datasets do not contain particle and grid data, respectively, or if <code>n0</code> is provided but <code>xi_var</code> is not.</p>"},{"location":"reference/statistics/#ozzy.statistics.charge_in_field_quadrants(raw_ds)","title":"<code>raw_ds</code>","text":""},{"location":"reference/statistics/#ozzy.statistics.charge_in_field_quadrants(fields_ds)","title":"<code>fields_ds</code>","text":""},{"location":"reference/statistics/#ozzy.statistics.charge_in_field_quadrants(t_var)","title":"<code>t_var</code>","text":""},{"location":"reference/statistics/#ozzy.statistics.charge_in_field_quadrants(w_var)","title":"<code>w_var</code>","text":""},{"location":"reference/statistics/#ozzy.statistics.charge_in_field_quadrants(n0)","title":"<code>n0</code>","text":""},{"location":"reference/statistics/#ozzy.statistics.charge_in_field_quadrants(xi_var)","title":"<code>xi_var</code>","text":""},{"location":"reference/statistics/#ozzy.statistics.field_space","title":"field_space","text":"<pre><code>field_space(raw_ds, fields_ds, spatial_dims=['x1', 'x2'])\n</code></pre> <p>Get values of fields in the cell where each particle is located (no interpolation is done).</p> <p>Parameters:</p> Name Type Description Default <code>Dataset</code> <p>Dataset containing particle data.</p> required <code>Dataset</code> <p>Dataset containing field data.</p> required <code>list[str]</code> <p>List of spatial dimension names in the input datasets. Default is <code>['x1', 'x2']</code>.</p> <code>['x1', 'x2']</code> <p>Returns:</p> Name Type Description <code>raw_ds</code> <code>Dataset</code> <p>Dataset containing particle data with interpolated field values.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the input datasets contain a time dimension, or if the input datasets do not contain particle and grid data, respectively.</p> Warning <p>This function assumes that the second element of <code>spatial_dims</code> is the vertical dimension.</p>"},{"location":"reference/statistics/#ozzy.statistics.field_space(raw_ds)","title":"<code>raw_ds</code>","text":""},{"location":"reference/statistics/#ozzy.statistics.field_space(fields_ds)","title":"<code>fields_ds</code>","text":""},{"location":"reference/statistics/#ozzy.statistics.field_space(spatial_dims)","title":"<code>spatial_dims</code>","text":""},{"location":"reference/utils/","title":"ozzy.utils","text":"<p>This submodule provides utility functions for other parts of ozzy, from simple formatting operations to more complicated file-finding tasks.</p>"},{"location":"reference/utils/#ozzy.utils.axis_from_extent","title":"axis_from_extent","text":"<pre><code>axis_from_extent(nx, lims)\n</code></pre> <p>Create a numerical axis from the number of cells and extent limits. The axis values are centered with respect to each cell.</p> <p>Parameters:</p> Name Type Description Default <code>int</code> <p>The number of cells in the axis.</p> required <code>tuple[float, float]</code> <p>The extent limits (min, max).</p> required <p>Returns:</p> Name Type Description <code>ax</code> <code>ndarray</code> <p>The numerical axis.</p> <p>Raises:</p> Type Description <code>ZeroDivisionError</code> <p>If the number of cells is zero.</p> <code>TypeError</code> <p>If the second element of <code>lims</code> is not larger than the first element.</p> <p>Examples:</p> Simple axis <p></p><pre><code>import ozzy as oz\naxis = oz.utils.axis_from_extent(10, (0,1))\naxis\n# array([0.05, 0.15, 0.25, 0.35, 0.45, 0.55, 0.65, 0.75, 0.85, 0.95])\n</code></pre> Note how the axis values correspond to the center of each cell.<p></p>"},{"location":"reference/utils/#ozzy.utils.axis_from_extent(nx)","title":"<code>nx</code>","text":""},{"location":"reference/utils/#ozzy.utils.axis_from_extent(lims)","title":"<code>lims</code>","text":""},{"location":"reference/utils/#ozzy.utils.bins_from_axis","title":"bins_from_axis","text":"<pre><code>bins_from_axis(axis)\n</code></pre> <p>Create bin edges from a numerical axis. This is useful for binning operations that require the bin edges.</p> <p>Parameters:</p> Name Type Description Default <code>ndarray</code> <p>The numerical axis.</p> required <p>Returns:</p> Name Type Description <code>binaxis</code> <code>ndarray</code> <p>The bin edges.</p> <p>Examples:</p> Bin edges from simple axis <p>First we create a simple axis with the <code>axis_from_extent</code> function:</p> <p></p><pre><code>import ozzy as oz\naxis = oz.utils.axis_from_extent(10, (0,1))\nprint(axis)\n# [0.05 0.15 0.25 0.35 0.45 0.55 0.65 0.75 0.85 0.95]\n</code></pre> Now we get the bin edges:<p></p> <pre><code>bedges = oz.utils.bins_from_axis(axis)\nbedges\n# array([-6.9388939e-18,  1.0000000e-01,  2.0000000e-01,  3.0000000e-01, 4.0000000e-01,  5.0000000e-01,  6.0000000e-01,  7.0000000e-01, 8.0000000e-01,  9.0000000e-01,  1.0000000e+00])\n</code></pre> <p>(In this example there is some rounding error for the zero edge.)</p>"},{"location":"reference/utils/#ozzy.utils.bins_from_axis(axis)","title":"<code>axis</code>","text":""},{"location":"reference/utils/#ozzy.utils.check_h5_availability","title":"check_h5_availability","text":"<pre><code>check_h5_availability(path)\n</code></pre> <p>Check if an HDF5 file can be opened for writing.</p> <p>Note</p> <p>This method is useful for longer analysis operations that save a file at the end. Without checking the output file writeability at the beginning, there is the risk of undergoing the lengthy processing and then failing to write the result to a file at the end.</p> <p>Parameters:</p> Name Type Description Default <code>str</code> <p>The path to the HDF5 file.</p> required <p>Raises:</p> Type Description <code>FileNotFoundError</code> <p>If the file is not found.</p> <code>BlockingIOError</code> <p>If the file is in use and cannot be overwritten.</p> <code>OSError</code> <p>If there is another issue with the file.</p> <p>Examples:</p> Writing a custom analysis function <pre><code>import ozzy as oz\n\ndef my_analysis(ds, output_file='output.h5'):\n\n    # Check whether output file is writeable\n    oz.utils.check_h5_availability(output_file)\n\n    # Perform lengthy analysis\n    # ...\n    new_ds = 10 * ds\n\n    # Save result\n    new_ds.ozzy.save(output_file)\n\n    return\n</code></pre>"},{"location":"reference/utils/#ozzy.utils.check_h5_availability(path)","title":"<code>path</code>","text":""},{"location":"reference/utils/#ozzy.utils.convert_interval_to_mid","title":"convert_interval_to_mid","text":"<pre><code>convert_interval_to_mid(da)\n</code></pre> <p>Convert <code>xarray.DataArray</code> of <code>pandas.Interval</code> objects to an array of their midpoints.</p> <p>Parameters:</p> Name Type Description Default <code>DataArray</code> <p>An <code>xarray.DataArray</code> containing <code>pandas.Interval</code> objects.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>A <code>numpy.ndarray</code> containing the midpoint values of each interval.</p> <p>Raises:</p> Type Description <code>AttributeError</code> <p>If the elements in the DataArray are not <code>pandas.Interval</code> objects.</p> <p>Examples:</p> Basic usage with interval data <pre><code>import pandas as pd\nimport numpy as np\nimport xarray as xr\n\n# Create an array of pandas Interval objects\nintervals = [pd.Interval(0, 10), pd.Interval(10, 20), pd.Interval(20, 30)]\n\n# Create an xarray DataArray\nda = xr.DataArray(intervals)\n\n# Get the midpoints\nmid_points = convert_interval_to_mid(da)\n# Output: array([ 5., 15., 25.])\n</code></pre> Handling 2D interval data <pre><code>import pandas as pd\nimport numpy as np\nimport xarray as xr\n\n# Create a 2D array of pandas Interval objects\nintervals_2d = [[pd.Interval(0, 2), pd.Interval(2, 4)],\n                [pd.Interval(4, 6), pd.Interval(6, 8)]]\n\n# Create an xarray DataArray\nda_2d = xr.DataArray(intervals_2d)\n\n# Get the midpoints\nmid_points_2d = convert_interval_to_mid(da_2d)\n# Output: array([[1., 3.], [5., 7.]])\n</code></pre>"},{"location":"reference/utils/#ozzy.utils.convert_interval_to_mid(da)","title":"<code>da</code>","text":""},{"location":"reference/utils/#ozzy.utils.find_runs","title":"find_runs","text":"<pre><code>find_runs(path, runs_pattern)\n</code></pre> <p>Find run directories matching a glob pattern.</p> <p>Parameters:</p> Name Type Description Default <code>str</code> <p>The base path.</p> required <code>str | list[str]</code> <p>The run directory name or glob pattern(s).</p> required <p>Returns:</p> Name Type Description <code>dirs_dict</code> <code>dict</code> <p>A dictionary mapping run names to their relative directory paths.</p> <p>Examples:</p> Finding set of run folders <p>Let's say we have a set of simulations that pick up from different checkpoints of a baseline simulation, with the following folder tree:</p> <pre><code>.\n\u2514\u2500\u2500 all_simulations/\n    \u251c\u2500\u2500 baseline/\n    \u2502   \u251c\u2500\u2500 data.h5\n    \u2502   \u251c\u2500\u2500 checkpoint_t_00200.h5\n    \u2502   \u251c\u2500\u2500 checkpoint_t_00400.h5\n    \u2502   \u251c\u2500\u2500 checkpoint_t_00600.h5\n    \u2502   \u2514\u2500\u2500 ...\n    \u251c\u2500\u2500 from_t_00200/\n    \u2502   \u2514\u2500\u2500 data.h5\n    \u251c\u2500\u2500 from_t_00400/\n    \u2502   \u2514\u2500\u2500 data.h5\n    \u251c\u2500\u2500 from_t_00600/\n    \u2502   \u2514\u2500\u2500 data.h5\n    \u251c\u2500\u2500 ...\n    \u2514\u2500\u2500 other_simulation\n</code></pre> <p>To get the directories of each subfolder, we could use either </p><pre><code>import ozzy as oz\nrun_dirs = oz.utils.find_runs(path = \"all_simulations\", runs_pattern = \"from_t_*\")\nprint(run_dirs)\n# {'from_t_00200': 'from_t_00200', 'from_t_00400': 'from_t_00400', ...}\n</code></pre> or <pre><code>import ozzy as oz\nrun_dirs = oz.utils.find_runs(path = \".\", runs_pattern = \"all_simulations/from_t_*\")\nprint(run_dirs)\n# {'from_t_00200': 'all_simulations/from_t_00200', 'from_t_00400': 'all_simulations/from_t_00400', ...}\n</code></pre><p></p> <p>Note that this function does not work recursively, though it still returns the current directory if no run folders are found: </p><pre><code>import ozzy as oz\nrun_dirs = oz.utils.find_runs(path = \".\", runs_pattern = \"from_t_*\")\n# Could not find any run folder:\n# - Checking whether already inside folder...\n#     ...no\n# - Proceeding without a run name.\nprint(run_dirs)\n# {'undefined': '.'}\n</code></pre><p></p>"},{"location":"reference/utils/#ozzy.utils.find_runs(path)","title":"<code>path</code>","text":""},{"location":"reference/utils/#ozzy.utils.find_runs(runs_pattern)","title":"<code>runs_pattern</code>","text":""},{"location":"reference/utils/#ozzy.utils.force_str_to_list","title":"force_str_to_list","text":"<pre><code>force_str_to_list(var)\n</code></pre> <p>Convert a string to a list containing the string.</p> <p>Parameters:</p> Name Type Description Default <code>str | object</code> <p>The input variable.</p> required <p>Returns:</p> Name Type Description <code>var</code> <code>list</code> <p>A list containing the input variable if it was a string, or the original object.</p> <p>Examples:</p> Example <pre><code>import ozzy as oz\noz.utils.force_str_to_list('hello')\n# ['hello']\noz.utils.force_str_to_list([1, 2, 3])\n# [1, 2, 3]\n</code></pre>"},{"location":"reference/utils/#ozzy.utils.force_str_to_list(var)","title":"<code>var</code>","text":""},{"location":"reference/utils/#ozzy.utils.get_attr_if_exists","title":"get_attr_if_exists","text":"<pre><code>get_attr_if_exists(\n    da, attr, str_exists=None, str_doesnt=None\n)\n</code></pre> <p>Retrieve an attribute from a xarray DataArray if it exists, or return a specified value otherwise.</p> <p>Parameters:</p> Name Type Description Default <code>DataArray</code> <p>The xarray DataArray object to check for the attribute.</p> required <code>str</code> <p>The name of the attribute to retrieve.</p> required <code>str | Iterable[str] | Callable | None</code> <p>The value or function to use if the attribute exists. If <code>str</code>: return as-is. If <code>Iterable</code>: concatenate the first element, existing value, and second element. If <code>Callable</code>: apply this function to the existing attribute value. If <code>None</code>: return attribute if it exists, otherwise return <code>None</code>.</p> <code>None</code> <code>str | None</code> <p>The value to return if the attribute doesn't exist. If <code>None</code>, returns <code>None</code>.</p> <code>None</code> <p>Returns:</p> Type Description <code>str | None</code> <p>The processed attribute value if it exists, <code>str_doesnt</code> if it doesn't exist, or <code>None</code> if <code>str_doesnt</code> is <code>None</code> and the attribute doesn't exist.</p> Notes <p>If <code>str_exists</code> is an <code>Iterable</code> with more than two elements, only the first two are used, and a warning is printed.</p> <p>Examples:</p> Basic usage with string <pre><code>import ozzy as oz\nimport numpy as np\n\n# Create a sample DataArray with an attribute\nda = oz.DataArray(np.random.rand(3, 3), attrs={'units': 'meters'})\n\nresult = get_attr_if_exists(da, 'missing_attr', 'Exists', 'Does not exist')\nprint(result)\n# Output: Does not exist\n</code></pre> Using an Iterable and a Callable <pre><code>import ozzy as oz\nimport numpy as np\n\nda = oz.DataArray(np.random.rand(3, 3), attrs={'units': 'meters'})\n\n# Using an Iterable\nresult = get_attr_if_exists(da, 'units', ['Unit: ', ' (SI)'], 'No unit')\nprint(result)\n# Output: Unit: meters (SI)\n\nresult = get_attr_if_exists(da, 'units', lambda x: f'The unit is: {x}', 'No unit found')\nprint(result)\n# Output: The unit is: meters\n\n# Using a Callable\nresult = get_attr_if_exists(da, 'units', lambda x: x.upper(), 'No unit')\nprint(result)\n# Output: METERS\n</code></pre>"},{"location":"reference/utils/#ozzy.utils.get_attr_if_exists(da)","title":"<code>da</code>","text":""},{"location":"reference/utils/#ozzy.utils.get_attr_if_exists(attr)","title":"<code>attr</code>","text":""},{"location":"reference/utils/#ozzy.utils.get_attr_if_exists(str_exists)","title":"<code>str_exists</code>","text":""},{"location":"reference/utils/#ozzy.utils.get_attr_if_exists(str_doesnt)","title":"<code>str_doesnt</code>","text":""},{"location":"reference/utils/#ozzy.utils.get_regex_snippet","title":"get_regex_snippet","text":"<pre><code>get_regex_snippet(pattern, string)\n</code></pre> <p>Extract a regex pattern from a string using <code>re.search</code>.</p> <p>Tip</p> <p>Use regex101.com to experiment with and debug regular expressions.</p> <p>Parameters:</p> Name Type Description Default <code>str</code> <p>The regular expression pattern.</p> required <code>str</code> <p>The input string.</p> required <p>Returns:</p> Name Type Description <code>match</code> <code>str</code> <p>The matched substring.</p> <p>Examples:</p> Get number from file name <pre><code>import ozzy as oz\noz.utils.get_regex_snippet(r'\\d+', 'field-001234.h5')\n# '001234'\n</code></pre>"},{"location":"reference/utils/#ozzy.utils.get_regex_snippet(pattern)","title":"<code>pattern</code>","text":""},{"location":"reference/utils/#ozzy.utils.get_regex_snippet(string)","title":"<code>string</code>","text":""},{"location":"reference/utils/#ozzy.utils.get_user_methods","title":"get_user_methods","text":"<pre><code>get_user_methods(clss)\n</code></pre> <p>Get a list of user-defined methods in a class.</p> <p>Parameters:</p> Name Type Description Default <code>class</code> <p>The input class.</p> required <p>Returns:</p> Name Type Description <code>methods</code> <code>list[str]</code> <p>A list of user-defined method names in the class.</p> <p>Examples:</p> Minimal class <pre><code>class MyClass:\n    def __init__(self):\n        pass\n    def my_method(self):\n        pass\n\nimport ozzy as oz\noz.utils.get_user_methods(MyClass)\n# ['my_method']\n</code></pre>"},{"location":"reference/utils/#ozzy.utils.get_user_methods(clss)","title":"<code>clss</code>","text":""},{"location":"reference/utils/#ozzy.utils.insert_str_at_index","title":"insert_str_at_index","text":"<pre><code>insert_str_at_index(original, inserted, index)\n</code></pre> <p>Insert a string into another string at a specified index position.</p> <p>Parameters:</p> Name Type Description Default <code>str</code> <p>The original string that will be modified.</p> required <code>str</code> <p>The string to be inserted into the original string.</p> required <code>int</code> <p>The position where the insertion should occur.</p> required <p>Returns:</p> Type Description <code>str</code> <p>A new string with the inserted content at the specified index.</p> <p>Examples:</p> Hello Beautiful World <pre><code>from ozzy.utils import insert_str_at_index\n\ninsert_str_at_index(\"Hello World\", \" Beautiful\", 5)\n# Output: \"Hello Beautiful World\"\n</code></pre> SuperPython <pre><code>from ozzy.utils import insert_str_at_index\n\ninsert_str_at_index(\"Python\", \"Super\", 0)\n# Output: \"SuperPython\"\n</code></pre>"},{"location":"reference/utils/#ozzy.utils.insert_str_at_index(original)","title":"<code>original</code>","text":""},{"location":"reference/utils/#ozzy.utils.insert_str_at_index(inserted)","title":"<code>inserted</code>","text":""},{"location":"reference/utils/#ozzy.utils.insert_str_at_index(index)","title":"<code>index</code>","text":""},{"location":"reference/utils/#ozzy.utils.path_list_to_pars","title":"path_list_to_pars","text":"<pre><code>path_list_to_pars(pathlist)\n</code></pre> <p>Split a list of file paths into common directory, run directories, and quantities.</p> <p>Parameters:</p> Name Type Description Default <code>list[str]</code> <p>A list of file paths.</p> required <p>Returns:</p> Name Type Description <code>common_dir</code> <code>str</code> <p>The common directory shared by all file paths.</p> <code>dirs_runs</code> <code>dict[str, str]</code> <p>A dictionary mapping run folder names to their absolute paths.</p> <code>quants</code> <code>list[str]</code> <p>A list of unique quantities (file names) present in the input paths.</p> <p>Examples:</p> Simple example <pre><code>import os\nfrom ozzy.utils import path_list_to_pars\n\npathlist = ['/path/to/run1/quantity1.txt',\n            '/path/to/run1/quantity2.txt',\n            '/path/to/run2/quantity1.txt']\n\ncommon_dir, dirs_runs, quants = path_list_to_pars(pathlist)\n\nprint(f\"Common directory: {common_dir}\")\n# Common directory: /path/to\nprint(f\"Run directories: {dirs_runs}\")\n# Run directories: {'run1': '/path/to/run1', 'run2': '/path/to/run2'}\nprint(f\"Quantities: {quants}\")\n# Quantities: ['quantity2.txt', 'quantity1.txt']\n</code></pre> Single file path <pre><code>import os\nfrom ozzy.utils import path_list_to_pars\n\npathlist = ['/path/to/run1/quantity.txt']\n\ncommon_dir, dirs_runs, quants = path_list_to_pars(pathlist)\n\nprint(f\"Common directory: {common_dir}\")\n# Common directory: /path/to/run1\nprint(f\"Run directories: {dirs_runs}\")\n# Run directories: {'.': '/path/to/run1'}\nprint(f\"Quantities: {quants}\")\n# Quantities: ['quantity.txt']\n</code></pre>"},{"location":"reference/utils/#ozzy.utils.path_list_to_pars(pathlist)","title":"<code>pathlist</code>","text":""},{"location":"reference/utils/#ozzy.utils.prep_file_input","title":"prep_file_input","text":"<pre><code>prep_file_input(files)\n</code></pre> <p>Prepare path input argument by expanding user paths and converting to absolute paths.</p> <p>Parameters:</p> Name Type Description Default <code>str | list of str</code> <p>The input file(s).</p> required <p>Returns:</p> Name Type Description <code>filelist</code> <code>list of str</code> <p>A list of absolute file paths.</p> <p>Examples:</p> Expand user folder <pre><code>import ozzy as oz\noz.utils.prep_file_input('~/example.txt')\n# ['/home/user/example.txt']\noz.utils.prep_file_input(['~/file1.txt', '~/file2.txt'])\n# ['/home/user/file1.txt', '/home/user/file2.txt']\n</code></pre>"},{"location":"reference/utils/#ozzy.utils.prep_file_input(files)","title":"<code>files</code>","text":""},{"location":"reference/utils/#ozzy.utils.print_file_item","title":"print_file_item","text":"<pre><code>print_file_item(file)\n</code></pre> <p>Print a file name with a leading '  - '.</p> <p>Parameters:</p> Name Type Description Default <code>str</code> <p>The file name to be printed.</p> required <p>Examples:</p> Example <pre><code>import ozzy as oz\noz.utils.print_file_item('example.txt')\n# - example.txt\n</code></pre>"},{"location":"reference/utils/#ozzy.utils.print_file_item(file)","title":"<code>file</code>","text":""},{"location":"reference/utils/#ozzy.utils.recursive_search_for_file","title":"recursive_search_for_file","text":"<pre><code>recursive_search_for_file(fname, path=os.getcwd())\n</code></pre> <p>Recursively search for files with a given name or pattern in a specified directory and its subdirectories.</p> <p>Parameters:</p> Name Type Description Default <code>str</code> <p>The name or name pattern of the file to search for.</p> required <code>str</code> <p>The path to the directory where the search should start. If not specified, uses the current directory via <code>os.getcwd</code>.</p> <code>getcwd()</code> <p>Returns:</p> Type Description <code>list[str]</code> <p>A list of paths to the files found, relative to <code>path</code>.</p> <p>Examples:</p> Search for a file in the current directory <pre><code>from ozzy.utils import recursive_search_for_file\nfiles = recursive_search_for_file('example.txt')\n# files = ['/path/to/current/dir/example.txt']\n</code></pre> Search for many files in a subdirectory <pre><code>from ozzy.utils import recursive_search_for_file\nfiles = recursive_search_for_file('data-*.h5', '/path/to/project')\n# files = ['data/data-000.h5', 'data/data-001.h5', 'analysis/data-modified.h5']\n</code></pre>"},{"location":"reference/utils/#ozzy.utils.recursive_search_for_file(fname)","title":"<code>fname</code>","text":""},{"location":"reference/utils/#ozzy.utils.recursive_search_for_file(path)","title":"<code>path</code>","text":""},{"location":"reference/utils/#ozzy.utils.set_attr_if_exists","title":"set_attr_if_exists","text":"<pre><code>set_attr_if_exists(\n    da, attr, str_exists=None, str_doesnt=None\n)\n</code></pre> <p>Set or modify an attribute of a DataArray if it exists, or modify if it doesn't exist or is <code>None</code>.</p> <p>Parameters:</p> Name Type Description Default <code>DataArray</code> <p>The input DataArray.</p> required <code>str</code> <p>The name of the attribute to set or modify.</p> required <code>str | Iterable[str] | Callable | None</code> <p>The value or function to use if the attribute exists. If <code>str</code>: replace the attribute with this string. If <code>Iterable</code>: concatenate the first element, existing value, and second element. If <code>Callable</code>: apply this function to the existing attribute value. If <code>None</code>: do not change the attribute.</p> <code>None</code> <code>str | None</code> <p>The value to set if the attribute doesn't exist. If <code>None</code>, no action is taken.</p> <code>None</code> <p>Returns:</p> Type Description <code>DataArray</code> <p>The modified DataArray with updated attributes.</p> Notes <p>If <code>str_exists</code> is an <code>Iterable</code> with more than two elements, only the first two are used, and a warning is printed.</p> <p>Examples:</p> Set an existing attribute <pre><code>import ozzy as oz\nimport numpy as np\n\n# Create a sample DataArray\nda = oz.DataArray(np.random.rand(3, 3), attrs={'units': 'meters'})\n\n# Set an existing attribute\nda = set_attr_if_exists(da, 'units', 'kilometers')\nprint(da.attrs['units'])\n# Output: kilometers\n</code></pre> Modify an existing attribute with a function <pre><code>import ozzy as oz\nimport numpy as np\n\n# Create a sample DataArray\nda = oz.DataArray(np.random.rand(3, 3), attrs={'description': 'Random data'})\n\n# Modify an existing attribute with a function\nda = set_attr_if_exists(da, 'description', lambda x: x.upper())\nprint(da.attrs['description'])\n# Output: RANDOM DATA\n</code></pre> Set a non-existing attribute <pre><code>import ozzy as oz\nimport numpy as np\n\n# Create a sample DataArray\nda = oz.DataArray(np.random.rand(3, 3))\n\n# Set a non-existing attribute\nda = set_attr_if_exists(da, 'units', 'meters', str_doesnt='unknown')\nprint(da.attrs['units'])\n# Output: unknown\n</code></pre>"},{"location":"reference/utils/#ozzy.utils.set_attr_if_exists(da)","title":"<code>da</code>","text":""},{"location":"reference/utils/#ozzy.utils.set_attr_if_exists(attr)","title":"<code>attr</code>","text":""},{"location":"reference/utils/#ozzy.utils.set_attr_if_exists(str_exists)","title":"<code>str_exists</code>","text":""},{"location":"reference/utils/#ozzy.utils.set_attr_if_exists(str_doesnt)","title":"<code>str_doesnt</code>","text":""},{"location":"reference/utils/#ozzy.utils.stopwatch","title":"stopwatch","text":"<pre><code>stopwatch(method)\n</code></pre> <p>Decorator function to measure the execution time of a method.</p> <p>Parameters:</p> Name Type Description Default <code>callable</code> <p>The method to be timed.</p> required <p>Returns:</p> Name Type Description <code>timed</code> <code>callable</code> <p>A wrapped version of the input method that prints the execution time.</p> <p>Examples:</p> Get execution time whenever a function is called <pre><code>from ozzy.utils import stopwatch\n\n@stopwatch\ndef my_function(a, b):\n    return a + b\n\nmy_function(2, 3)\n# -&gt; 'my_function' took: 0:00:00.000001\n# 5\n</code></pre>"},{"location":"reference/utils/#ozzy.utils.stopwatch(method)","title":"<code>method</code>","text":""},{"location":"reference/utils/#ozzy.utils.tex_format","title":"tex_format","text":"<pre><code>tex_format(str)\n</code></pre> <p>Format a string for TeX by enclosing it with '$' symbols.</p> <p>Parameters:</p> Name Type Description Default <code>str</code> <p>The input string.</p> required <p>Returns:</p> Name Type Description <code>newstr</code> <code>str</code> <p>The TeX-formatted string.</p> <p>Examples:</p> Example <pre><code>import ozzy as oz\noz.utils.tex_format('k_p^2')\n# '$k_p^2$'\noz.utils.tex_format('')\n# ''\n</code></pre>"},{"location":"reference/utils/#ozzy.utils.tex_format(str)","title":"<code>str</code>","text":""},{"location":"reference/utils/#ozzy.utils.unpack_attr","title":"unpack_attr","text":"<pre><code>unpack_attr(attr)\n</code></pre> <p>Unpack a NumPy array attribute, typically from HDF5 files.</p> <p>This function handles different shapes and data types of NumPy arrays, particularly focusing on string (byte string) attributes. It's useful for unpacking attributes read from HDF5 files using h5py.</p> <p>Parameters:</p> Name Type Description Default <code>ndarray</code> <p>The input NumPy array to unpack.</p> required <p>Returns:</p> Type Description <code>object</code> <p>The unpacked attribute. For string attributes, it returns a UTF-8 decoded string. For other types, it returns either a single element (if the array has only one element) or the entire array.</p> <p>Raises:</p> Type Description <code>AssertionError</code> <p>If the input is not a NumPy array.</p> Notes <ul> <li>For string attributes (<code>dtype.kind == 'S'</code>):<ul> <li>0D arrays: returns the decoded string</li> <li>1D arrays: returns the first element decoded</li> <li>2D arrays: returns the first element if size is 1, otherwise the entire array</li> </ul> </li> <li>For non-string attributes:<ul> <li>If the array has only one element, returns that element</li> <li>Otherwise, returns the entire array</li> </ul> </li> </ul> <p>Examples:</p> Unpacking a string attribute <pre><code>import numpy as np\nimport ozzy.utils as utils\n\n# Create a NumPy array with a byte string\nattr = np.array(b'Hello, World!')\nresult = utils.unpack_attr(attr)\nprint(result)\n# Output: Hello, World!\n</code></pre> Unpacking a numeric attribute <pre><code>import numpy as np\nimport ozzy.utils as utils\n\n# Create a NumPy array with a single number\nattr = np.array([42])\nresult = utils.unpack_attr(attr)\nprint(result)\n# Output: 42\n</code></pre>"},{"location":"reference/utils/#ozzy.utils.unpack_attr(attr)","title":"<code>attr</code>","text":""},{"location":"reference/backends/","title":"Backends","text":""},{"location":"reference/backends/#backends","title":"Backends","text":"<p>Please navigate to a specific section for more information about the implementation of each simulation file type.</p> <ul> <li>LCODE</li> <li>OSIRIS</li> <li>ozzy</li> </ul> <p>If you're looking for the backend-specific methods that you can call on a data object, see Data object methods \u2192 Backend-specific methods.</p>"},{"location":"reference/backends/#interface-class","title":"Interface class","text":"<p>Info</p> <p>This section should only be relevant if you're planning to add support for a new backend or for debugging purposes.</p> <p>The <code>Backend</code> class serves as an interface between ozzy's main file-reading functions and the modules for each implemented backend. </p>"},{"location":"reference/backends/#ozzy.backend_interface.Backend","title":"Backend","text":"<p>Interface class for reading simulation data. Upon initialization, the Backend instance imports a specific submodule for a given data format and defines its data-parsing methods accordingly.</p> <p>Attributes:</p> Name Type Description <code>name</code> <code>str</code> <p>Name of the backend (e.g. <code>'osiris'</code>).</p> <code>parse</code> <code>function</code> <p>Function for parsing data from files.</p> <code>mixin</code> <code>class</code> <p>Mixin class that makes methods available to the data object depending on the file backend/data origin (<code>'osiris'</code>, <code>'ozzy'</code>, <code>'lcode'</code>).</p> <p>Methods:</p> Name Description <code>find_quants</code> <p>Find matching files for quantities.</p> <code>_load_quant_files</code> <p>Load quantity files (calls <code>find_quants()</code>).</p> <code>parse_data</code> <p>Read data from files and attach metadata.</p> <p>Examples:</p> Create a new Backend instance and read files <pre><code>backend = Backend('osiris')\nfiles = backend.find_quants(path='sim_dir', dirs_runs={'run1': 'run1_dir'}, quants=['e2', 'b3'])\ndata = backend.parse_data(files)\n</code></pre>"},{"location":"reference/backends/#ozzy.backend_interface.Backend.find_quants","title":"find_quants","text":"<pre><code>find_quants(path, dirs_runs, quants=None)\n</code></pre> <p>Searches <code>path</code> for files matching <code>quants</code> in the run directories specified by <code>dirs_runs</code>. All arguments may contain glob patterns.</p> <p>Parameters:</p> Name Type Description Default <code>str</code> <p>The base path to search for files.</p> required <code>dict[str, str]</code> <p>A dictionary mapping run names to directory paths relative to <code>path</code>.</p> <p>Tip</p> <p>The <code>dirs_runs</code> parameter can be obtained by running <code>ozzy.find_runs(path, runs_pattern)</code>. For example:</p> <pre><code>import ozzy as oz\ndirs_runs = oz.find_runs(path='sim_dir', runs_pattern='param_scan_*')\n</code></pre> required <code>str, or list[str]</code> <p>A quantity name or list of quantity names to search for. The search term may contain the full filename (<code>'e1-000001.h5'</code>), only the quantity name (<code>'e1'</code>) or any combination with a glob pattern (<code>'e1-*'</code>, <code>'e1-*.h5'</code>). If not provided, any files with the file endings associated with this <code>Backend</code> are searched for.</p> <code>None</code> <p>Returns:</p> Type Description <code>dict[str, list[str]]</code> <p>A dictionary mapping quantity names to lists of matching file names.</p> <p>Examples:</p> Search for files with a specific quantity <pre><code>import ozzy.backend_interface as obi\nbackend = obi.Backend('lcode')\ndirs_runs = {'run1': 'path/to/run1', 'run2': 'path/to/run2'}\nquants_dict = backend.find_quants('/base/path', dirs_runs, 'xi_Ez')\n# quants_dict = {'xi_Ez': ['xi_Ez_0001.swp', 'xi_Ez_0002.swp', ...]}\n</code></pre> Search for files with any quantity <pre><code>import ozzy.backend_interface as obi\nbackend = obi.Backend('lcode')\ndirs_runs = {'run1': 'path/to/run1', 'run2': 'path/to/run2'}\nquants_dict = backend.find_quants('/base/path', dirs_runs)\n# quants_dict = {'xi_Ez': [...], 'xi_Er': [...], ...}\n</code></pre>"},{"location":"reference/backends/#ozzy.backend_interface.Backend.find_quants(path)","title":"<code>path</code>","text":""},{"location":"reference/backends/#ozzy.backend_interface.Backend.find_quants(dirs_runs)","title":"<code>dirs_runs</code>","text":""},{"location":"reference/backends/#ozzy.backend_interface.Backend.find_quants(quants)","title":"<code>quants</code>","text":""},{"location":"reference/backends/#ozzy.backend_interface.Backend.parse_data","title":"parse_data","text":"<pre><code>parse_data(files, *args, **kwargs)\n</code></pre> <p>Read data from files and attach metadata according to the selected <code>Backend</code>.</p> <p>Parameters:</p> Name Type Description Default <code>list[str]</code> <p>File paths to read data from.</p> required <p>Positional arguments to be passed to the <code>read</code> function of the backend specification.</p> <code>()</code> <p>Keyword arguments to be passed to the <code>read</code> function of the backend specification.</p> <p>See available keyword arguments for each backend:</p> <ul> <li>LCODE</li> <li>OSIRIS</li> <li>ozzy</li> </ul> <code>{}</code> <p>Returns:</p> Type Description <code>Dataset</code> <p>Parsed data. Includes the following Dataset attributes: <code>'file_backend'</code>, <code>'source'</code>, <code>'file_prefix'</code>, <code>'pic_data_type'</code> and <code>'data_origin'</code>.</p> <p>Examples:</p> Parse a single file <pre><code>from ozzy.backend_interface import Backend\n\nbackend = Backend('lcode')\nds = backend.parse_data(['path/to/file.swp'])\n</code></pre> Parse multiple files <pre><code>from ozzy.backend_interface import Backend\n\nbackend = Backend('osiris')\nds = backend.parse_data(['path/to/file1.h5', 'path/to/file2.h5'])\n</code></pre>"},{"location":"reference/backends/#ozzy.backend_interface.Backend.parse_data(files)","title":"<code>files</code>","text":""},{"location":"reference/backends/#ozzy.backend_interface.Backend.parse_data(*args)","title":"<code>*args</code>","text":""},{"location":"reference/backends/#ozzy.backend_interface.Backend.parse_data(**kwargs)","title":"<code>**kwargs</code>","text":""},{"location":"reference/backends/lcode/","title":"LCODE","text":""},{"location":"reference/backends/lcode/#lcode-backend","title":"LCODE backend","text":""},{"location":"reference/backends/lcode/#available-file-types","title":"Available file types","text":"<p>At the moment, the following LCODE 2D file types can be read by ozzy:</p> <ul> <li> plasma density profile along propagation (<code>plzshape.dat</code>)</li> <li> particle information at a single timestep (<code>tb?????.swp</code>,<code>beamfile.bin</code>)</li> <li> local/absolute extrema of on-axis longitudinal field or on-axis potential (<code>emaxf.dat</code>, <code>gmaxf.dat</code>, <code>elocf.dat</code>, <code>glocf.dat</code>)</li> <li> grid density data</li> <li> lineouts along longitudinal coordinate (<code>xi_*.swp</code>)</li> <li> particle data for selected particles (<code>partic.swp</code>) </li> <li> lost particle data (<code>beamlost.dat</code>)</li> <li> key between exact times of diagnostic outputs and their 5-digit representations (<code>times.dat</code>)</li> <li> trapped particle data (<code>captured.pls</code>)</li> <li> plasma particle data (<code>pl?????.swp</code>, <code>plasma.bin</code>)</li> <li> <p> full grid information for fields and currents (<code>fl?????.swp</code>, <code>fields.bin</code>)</p> </li> <li> <p> histogram of particle data</p> </li> <li> plasma particle data (<code>?????.pls</code>, <code>s?????.pls</code>)</li> <li> substepped lineouts along longitudinal coordinate (<code>u?????.det</code>, <code>v?????.det</code>)</li> <li> real and imaginary components of laser envelope (<code>ls??????.???.swp</code>)</li> </ul>"},{"location":"reference/backends/lcode/#default-metadata","title":"Default metadata","text":"<p>The variable metadata, such as the mathematical symbol and units, is inferred from the file name and file type. Since this translation is mostly hard-coded, some quantities have not yet been included and will therefore not be displayed as properly formatted metadata.</p> <p>The default metadata for each foreseen quantity can be inspected with: </p><pre><code>import ozzy as oz\nfor k, v in oz.backends.lcode_backend.quant_info.items():\n    print(k)\n    for k1, v1 in v.items():\n        print(f' {k1}:')\n        print(f'    label: {v1[0]}')\n        print(f'    units: {v1[1]}')\n</code></pre><p></p>"},{"location":"reference/backends/lcode/#entry-point-read-function","title":"Entry-point <code>read</code> function","text":""},{"location":"reference/backends/lcode/#ozzy.backends.lcode_backend.read","title":"read","text":"<pre><code>read(\n    files, axes_lims=None, axisym=True, abs_q=1.0, **kwargs\n)\n</code></pre> <p>Read one or more LCODE data files and create a Dataset.</p> <p>Parameters:</p> Name Type Description Default <code>list[str]</code> <p>A list of file paths to be read.</p> required <code>dict[str, tuple[float, float]] | None</code> <p>A dictionary specifying the limits for each axis in the data. Keys are axis names, and values are tuples of (min, max) values.</p> <code>None</code> <code>bool</code> <p>Whether the data is in 2D axisymmetric/cylindrical geometry.</p> <code>True</code> <code>float</code> <p>Absolute value of the charge of the bunch particles, in units of the elementary charge \\(e\\).</p> <p>This argument is used to normalize the particle momenta to \\(m_\\mathrm{sp} c\\) instead of LCODE's default of \\(m_e c\\).</p> <code>1.0</code> <p>Returns:</p> Type Description <code>Dataset</code> <p>A Dataset containing the data from the input files.</p> <p>Examples:</p> <p>Warning</p> <p>Note that you would not usually call this function directly, except in advanced use cases such as debugging. The examples below are included for completeness.</p> <p>In general, please use ozzy's file-reading functions along with the backend specification instead, for example: </p><pre><code>data = oz.open('lcode', 'path/to/file.swp')\n</code></pre><p></p> Reading grid files with axis limits <pre><code>from ozzy.backends.lcode_backend import read\n\nfiles = ['grid_file1.swp', 'grid_file2.swp']\naxes_lims = {'x1': (0, 10), 'x2': (-5, 5)}\nds = read(files, axes_lims)\n# Returns Dataset with grid data and axis coordinates\n</code></pre> Reading particle data with custom charge <p>The <code>abs_q</code> keyword argument is used to normalize the particle momenta to \\(m_\\mathrm{sp} c\\) (instead of LCODE's default of \\(m_e c\\)).</p> <pre><code>from ozzy.backends.lcode_backend import read\nfiles = ['tb00200.swp']\nds = read(files, axisym=True, abs_q=2.0)\n# Returns Dataset with particle momenta normalized to the species mass times the speed of light\n</code></pre>"},{"location":"reference/backends/lcode/#ozzy.backends.lcode_backend.read(files)","title":"<code>files</code>","text":""},{"location":"reference/backends/lcode/#ozzy.backends.lcode_backend.read(axes_lims)","title":"<code>axes_lims</code>","text":""},{"location":"reference/backends/lcode/#ozzy.backends.lcode_backend.read(axisym)","title":"<code>axisym</code>","text":""},{"location":"reference/backends/lcode/#ozzy.backends.lcode_backend.read(abs_q)","title":"<code>abs_q</code>","text":""},{"location":"reference/backends/osiris/","title":"OSIRIS","text":""},{"location":"reference/backends/osiris/#osiris-backend","title":"OSIRIS backend","text":""},{"location":"reference/backends/osiris/#available-file-types","title":"Available file types","text":"<p>At the moment, the following types of OSIRIS output files can be read by ozzy:</p> <ul> <li> grid (<code>DENSITY</code>, <code>FLD</code>, <code>PHA</code>)</li> <li> particles (<code>RAW</code>)</li> <li> particle tracks (<code>TRACKS</code>)</li> </ul>"},{"location":"reference/backends/osiris/#default-metadata","title":"Default metadata","text":"<p>Ozzy simply imports most of the metadata stored in OSIRIS HDF5 files as Dataset attributes (all attribute names are converted to lower case). </p> <p>The <code>'LABEL'</code> or <code>'LABELS'</code> attributes are renamed to <code>'long_name'</code>, since this is the default property that xarray looks for when labelling quantities in plots. All the label and unit metadata is encased in <code>'$...$'</code> so as to be rendered as LaTeX formulas in plots.</p> <p>In general, the names of the data dimensions correspond to the notation in OSIRIS (<code>'x1'</code>, <code>'x2'</code>, <code>'x3'</code>), while the time dimension is given the name <code>'t'</code>. An additional coordinate called <code>'iter'</code>, which contains the iteration number for a given time step, is indexed to the time dimension and attached to each dataset. </p> <p>Naming convention with a moving window</p> <p>When there is a moving window, the <code>'_box'</code> suffix is appended to the name of the dimension(s) concerned, since xarray requires the same window axes to concatenate grid data along time. The actual, time-varying axes are stored as a separate coordinate indexed to the same dimension.</p> <p>For example, for a two-dimensional window with a longitudinal axis initially spanning \\([-14,2] ~ k_p^{-1}\\), the Dataset obtained from the simulation data is shown below, depending on whether the simulation moves the window along <code>x1</code> or not.</p> <p>=== With a moving window</p> <pre><code>```python\n    print(ds)\n    # &lt;xarray.Dataset&gt;\n    # Dimensions:  (x2: 256, x1_box: 512, t: 31)\n    # Coordinates:\n    #     x1       (t, x1_box) float64 -13.98 -13.95 -13.92 ... 301.9 302.0 302.0\n    #   * x2       (x2) float64 0.0 0.03125 0.0625 0.09375 ... 7.875 7.906 7.938 7.969\n    #   * x1_box   (x1_box) float64 -13.98 -13.95 -13.92 -13.89 ... 1.922 1.953 1.984\n    #   * t        (t) float64 0.0 10.0 20.0 30.0 40.0 ... 270.0 280.0 290.0 300.0\n    #     iter     (t) int32 0 1280 2560 3840 5120 ... 33280 34560 35840 37120 38400\n    # Data variables:\n    #     charge   (x2, x1_box, t) float32 dask.array&lt;chunksize=(256, 512, 1), meta=np.ndarray&gt;\n    # Attributes:\n    #     move c:     [1 0]\n    #     ...\n```\n</code></pre> <p>=== No moving window</p> <pre><code>```python\n    print(ds)\n    # &lt;xarray.Dataset&gt;\n    # Dimensions:  (x2: 256, x1: 512, t: 31)\n    # Coordinates:\n    #   * x1       (x1) float64 -13.98 -13.95 -13.92 -13.89 ... 1.922 1.953 1.984\n    #   * x2       (x2) float64 0.0 0.03125 0.0625 0.09375 ... 7.875 7.906 7.938 7.969\n    #   * t        (t) float64 0.0 10.0 20.0 30.0 40.0 ... 270.0 280.0 290.0 300.0\n    #     iter     (t) int32 0 1280 2560 3840 5120 ... 33280 34560 35840 37120 38400\n    # Data variables:\n    #     charge   (x2, x1, t) float32 dask.array&lt;chunksize=(256, 512, 1), meta=np.ndarray&gt;\n    # Attributes: \n    #     move c:     [0 0]\n    #     ...\n```\n</code></pre> <p>Some quantities stored in OSIRIS HDF5 files are given specific labels and numbers instead of the ones attached to the file. These quantities are stored in a dictionary that maps the quantity name in the HDF5 files to a list containing two elements, the first for the new label and the second for the new units. The list for these quantities can be inspected with: </p><pre><code>import ozzy as oz\nprint(oz.backends.osiris_backend.special_vars)\n# {'ene': ['$E_{\\\\mathrm{kin}}$', '$m_\\\\mathrm{sp} c^2$']}\n</code></pre><p></p>"},{"location":"reference/backends/osiris/#entry-point-read-function","title":"Entry-point <code>read</code> function","text":""},{"location":"reference/backends/osiris/#ozzy.backends.osiris_backend.read","title":"read","text":"<pre><code>read(files, **kwargs)\n</code></pre> <p>Read OSIRIS HDF5 data files and return a Dataset.</p> <p>Parameters:</p> Name Type Description Default <code>list[str]</code> <p>List of paths to OSIRIS HDF5 data files</p> required <p>Returns:</p> Type Description <code>Dataset</code> <p>Dataset containing the OSIRIS simulation data with appropriate coordinates and attributes</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If data type is <code>'tracks-2'</code> which is not yet implemented</p> <code>ValueError</code> <p>If OSIRIS data type is unrecognized</p> <code>OSError</code> <p>If no valid files are provided or files cannot be opened</p> <p>Examples:</p> <p>Warning</p> <p>Note that you would not usually call this function directly, except in advanced use cases such as debugging. The examples below are included for completeness.</p> <p>In general, please use ozzy's file-reading functions along with the backend specification instead, for example: </p><pre><code>data = oz.open('osiris', 'path/to/file.h5')\n</code></pre><p></p> Reading grid data files <pre><code>from ozzy.backends.osiris_backend import read\nfiles = ['charge-electrons-000000.h5', 'charge-electrons-000001.h5']\ndataset = read(files)\n# Returns Dataset with grid data\n</code></pre> Reading particle data files <pre><code>from ozzy.backends.osiris_backend import read\nparticle_files = ['RAW-electrons-000010.h5']\ndataset = read(particle_files)\n# Returns Dataset with particle data\n</code></pre>"},{"location":"reference/backends/osiris/#ozzy.backends.osiris_backend.read(files)","title":"<code>files</code>","text":""},{"location":"reference/backends/ozzy/","title":"ozzy","text":""},{"location":"reference/backends/ozzy/#ozzy-backend","title":"Ozzy backend","text":"<p>When a file is saved via <code>Dataset.ozzy.save()</code> or <code>DataArray.ozzy.save()</code>, the data and metadata are mapped straightforwardly onto an HDF5 file structure (or NetCDF, if this is the selected format). This backend simply imports the file and ensures that the <code>'pic_data_type'</code> and <code>'data_origin'</code> are initialized correctly.</p>"},{"location":"reference/backends/ozzy/#entry-point-read-function","title":"Entry-point <code>read</code> function","text":""},{"location":"reference/backends/ozzy/#ozzy.backends.ozzy_backend.read","title":"read","text":"<pre><code>read(files, **kwargs)\n</code></pre> <p>Read and process data files into a Dataset.</p> <p>Parameters:</p> Name Type Description Default <code>str | list[str]</code> <p>Path or list of paths to data files to be read.</p> required <p>Returns:</p> Type Description <code>Dataset</code> <p>Dataset containing the processed data with these additional attributes: - <code>'source'</code>: common path of input files - <code>'files_prefix'</code>: common prefix of input filenames</p> <p>Examples:</p> <p>Warning</p> <p>Note that you would not usually call this function directly, except in advanced use cases such as debugging. The examples below are included for completeness.</p> <p>In general, please use ozzy's file-reading functions along with the backend specification instead, for example: </p><pre><code>data = oz.open('ozzy', 'path/to/file.h5')\n</code></pre><p></p> Reading a single file <pre><code>from ozzy.backends.ozzy_backend import read\nfile_path = \"data/processed_data.h5\"\ndataset = read(file_path)\nprint(dataset.attrs)\n# {'source': 'data', 'files_prefix': 'processed_data', ... }\n</code></pre> Reading multiple files <pre><code>from ozzy.backends.ozzy_backend import read\nfile_paths = [\"data/sim_1.h5\", \"data/sim_2.h5\"]\ndataset = read(file_paths)\nprint(dataset.dims)\n# Dimensions showing concatenated data along time axis\n</code></pre>"},{"location":"reference/backends/ozzy/#ozzy.backends.ozzy_backend.read(files)","title":"<code>files</code>","text":""},{"location":"reference/data-objects/","title":"Data object methods","text":""},{"location":"reference/data-objects/#data-object-methods","title":"Data object methods","text":"<p>Different methods are available depending on the type of PIC data (e.g. grid versus particle data), and on the PIC code the data originates from (e.g. OSIRIS versus LCODE). </p> <p>Please check the sections below for more details about all the available data object methods.</p> <ul> <li>General methods</li> <li>Data-type-specific methods</li> <li>Backend-specific methods</li> </ul>"},{"location":"reference/data-objects/#calling-a-method-on-an-ozzy-data-object","title":"Calling a method on an ozzy data object","text":"<p>Ozzy is implemented according to xarray's accessor model<sup>1</sup>. All the ozzy functionality built on top of xarray data objects (Datasets or DataArrays) can therefore be accessed via </p> DataArrayDataset <pre><code>xarray.DataArray.ozzy.&lt;method&gt;\n</code></pre> <pre><code>xarray.Dataset.ozzy.&lt;method&gt;\n</code></pre> Example <p>Saving a Dataset object:</p> <pre><code>import ozzy as oz\nds = oz.Dataset()\nds.ozzy.save('test.h5')\n#  -&gt; Saved file \"test.h5\" \n# -&gt; 'save' took: 0:00:00.212650\n</code></pre> Note for developers <p>Ozzy's custom methods are defined in two accessor classes:</p> <ul> <li><code>ozzy.accessors.OzzyDataset</code></li> <li><code>ozzy.accessors.OzzyDataArray</code></li> </ul> <p>Strictly speaking, the path to each method should be for example <code>ozzy.accessors.[OzzyDataset|OzzyDataArray].&lt;method&gt;</code>. However, this documentation page presents the methods as if they were under <code>xarray.[Dataset|DataArray].ozzy.&lt;method&gt;</code>, which is effectively how the user can access them.</p> <p>The methods in each accessor class can access the actual data object via <code>&lt;data_obj&gt;.ozzy._obj</code>. This is only relevant when defining new methods in the accessor classes.</p> <p>Example</p> <pre><code>import xarray as xr\nimport ozzy as oz\nds = xr.Dataset()\nassert ds == ds.ozzy._obj\n# True\n</code></pre> <ol> <li> <p>See Extending xarray using accessors \u21a9</p> </li> </ol>"},{"location":"reference/data-objects/general-methods/","title":"General methods","text":""},{"location":"reference/data-objects/general-methods/#general-methods","title":"General methods","text":"<p>The following methods are available to any ozzy data object, independently of the data type or PIC code.</p> xarray.DataArray.ozzyxarray.Dataset.ozzy <p>               Bases: <code>*mixins</code></p> <p>               Bases: <code>*mixins</code></p>"},{"location":"reference/data-objects/general-methods/#ozzy.accessors.OzzyDataArray.coord_to_physical_distance","title":"coord_to_physical_distance","text":"<pre><code>coord_to_physical_distance(\n    coord,\n    n0,\n    units=\"m\",\n    new_coord=None,\n    new_label=None,\n    set_as_default=True,\n)\n</code></pre> <p>Convert a coordinate to physical units based on the plasma density \\(n_0\\).</p> <p>This function calculates the skin depth based on the provided <code>n0</code> value and scales the specified coordinate <code>coord</code> by the skin depth. The scaled coordinate is assigned a new name (<code>new_coord</code> or a default name) and added to the dataset as a new coordinate. The new coordinate can also be assigned a custom label (<code>new_label</code>).</p> <p>Parameters:</p> Name Type Description Default <code>str</code> <p>Name of coordinate to convert.</p> required <code>float</code> <p>Value for the plasma electron density used to calculate the skin depth, in \\(\\mathrm{cm}^{-3}\\).</p> required <code>str</code> <p>The name to assign to the new coordinate. If not provided, a default name is generated based on <code>coord</code> and <code>units</code>.</p> <code>None</code> <code>str</code> <p>The label (<code>\"long_name\"</code> attribute) to assign to the new coordinate. If not provided, the label of <code>coord</code> is used, if available.</p> <code>None</code> <code>str</code> <p>The physical units for the new coordinate. Must be either <code>\"m\"</code> for meters or <code>\"cm\"</code> for centimeters.</p> <code>'m'</code> <code>bool</code> <p>If <code>True</code>, the new coordinate is set as the default coordinate for the corresponding dimension, replacing <code>coord</code>.</p> <code>True</code> <p>Returns:</p> Type Description <code>DataArray</code> <p>A new DataArray with the additional converted coordinate.</p> <p>Examples:</p> Converting normalized time units to propagation distance <pre><code>import ozzy as oz\nda = oz.DataArray([3,4,5], coords={'t': [0,1,2]}, dims='t')\nda_m = da.ozzy.coord_to_physical_distance('t', 1e18, new_coord='z') # z in m\nda_cm = da.ozzy.coord_to_physical_distance('t', 1e18, units='cm', new_coord='z') # z in cm\n</code></pre> Convert \\(r\\) coordinate to centimeters with new label <pre><code>import ozzy as oz\nimport numpy as np\n\nda = oz.DataArray({'var': np.random.rand(5, 10)},\n                coords={'x2': np.linspace(0, 1, 10)})\nn0 = 1e17  # cm^-3\nda_new = da.ozzy.coord_to_physical_distance('x2', n0, new_coord='r', units='cm')\n</code></pre>"},{"location":"reference/data-objects/general-methods/#ozzy.accessors.OzzyDataArray.coord_to_physical_distance(coord)","title":"<code>coord</code>","text":""},{"location":"reference/data-objects/general-methods/#ozzy.accessors.OzzyDataArray.coord_to_physical_distance(n0)","title":"<code>n0</code>","text":""},{"location":"reference/data-objects/general-methods/#ozzy.accessors.OzzyDataArray.coord_to_physical_distance(new_coord)","title":"<code>new_coord</code>","text":""},{"location":"reference/data-objects/general-methods/#ozzy.accessors.OzzyDataArray.coord_to_physical_distance(new_label)","title":"<code>new_label</code>","text":""},{"location":"reference/data-objects/general-methods/#ozzy.accessors.OzzyDataArray.coord_to_physical_distance(units)","title":"<code>units</code>","text":""},{"location":"reference/data-objects/general-methods/#ozzy.accessors.OzzyDataArray.coord_to_physical_distance(set_as_default)","title":"<code>set_as_default</code>","text":""},{"location":"reference/data-objects/general-methods/#ozzy.accessors.OzzyDataArray.fft","title":"fft","text":"<pre><code>fft(axes=None, dims=None, **kwargs)\n</code></pre> <p>Calculate the Fast Fourier Transform (FFT) of a <code>DataArray</code> along specified dimensions.</p> <p>Warning</p> <p>This method has not been thoroughly checked for accuracy yet. Please double-check your results with a different FFT function.</p> <p>Parameters:</p> Name Type Description Default <code>list[int]</code> <p>The integer indices of the axes to take FFT along.</p> <code>None</code> <code>list[str]</code> <p>Dimensions along which to compute the FFT. If provided, this takes precedence over <code>axes</code>.</p> <code>None</code> <p>Additional keyword arguments passed to <code>numpy.fft.fftn</code>.</p> <code>{}</code> <p>Returns:</p> Type Description <code>DataArray</code> <p>The FFT result as a new DataArray.</p> <p>Examples:</p> 1D FFT <pre><code>import ozzy as oz\nimport numpy as np\n\n# Create a 1D DataArray\nx = np.linspace(0, 10, 100)\nda = oz.DataArray(np.sin(2 * np.pi * x), coords=[x], dims=['x'], pic_data_type='grid')\n\n# Compute the 1D FFT\nda_fft = da.ozzy.fft(dims=['x'])\n# -&gt; 'fft' took: 0:00:00.085525\n</code></pre> 2D FFT <pre><code>import ozzy as oz\nimport numpy as np\n\n# Create a 2D DataArray\nx = np.linspace(0, 10, 100)\ny = np.linspace(0, 5, 50)\nX, Y = np.meshgrid(x, y)\nda = oz.DataArray(np.sin(2 * np.pi * X) * np.cos(2 * np.pi * Y),\n        coords=[y, x], dims=['y', 'x'], pic_data_type='grid')\n\n# Compute the 2D FFT\nda_fft = da.ozzy.fft(dims=['x', 'y'])\n# -&gt; 'fft' took: 0:00:00.006278\n</code></pre>"},{"location":"reference/data-objects/general-methods/#ozzy.accessors.OzzyDataArray.fft(axes)","title":"<code>axes</code>","text":""},{"location":"reference/data-objects/general-methods/#ozzy.accessors.OzzyDataArray.fft(dims)","title":"<code>dims</code>","text":""},{"location":"reference/data-objects/general-methods/#ozzy.accessors.OzzyDataArray.fft(**kwargs)","title":"<code>**kwargs</code>","text":""},{"location":"reference/data-objects/general-methods/#ozzy.accessors.OzzyDataArray.save","title":"save","text":"<pre><code>save(path)\n</code></pre> <p>Save data object to an HDF5 (default) or NetCDF file.</p> <p>Parameters:</p> Name Type Description Default <code>str</code> <p>The path to save the file to. Specify the file ending as <code>'.h5'</code> for HDF5 or <code>'.nc'</code> for NetCDF.</p> required <p>Examples:</p> Save empty DataArray <pre><code>import ozzy as oz\nds = oz.DataArray()\nds.ozzy.save('empty_file.h5')\n#  -&gt; Saved file \"empty_file.h5\"\n# -&gt; 'save' took: 0:00:00.197806\n</code></pre>"},{"location":"reference/data-objects/general-methods/#ozzy.accessors.OzzyDataArray.save(path)","title":"<code>path</code>","text":""},{"location":"reference/data-objects/general-methods/#ozzy.accessors.OzzyDataset.coord_to_physical_distance","title":"coord_to_physical_distance","text":"<pre><code>coord_to_physical_distance(\n    coord,\n    n0,\n    units=\"m\",\n    new_coord=None,\n    new_label=None,\n    set_as_default=True,\n)\n</code></pre> <p>Convert a coordinate to physical units based on the plasma density \\(n_0\\).</p> <p>This function calculates the skin depth based on the provided <code>n0</code> value and scales the specified coordinate <code>coord</code> by the skin depth. The scaled coordinate is assigned a new name (<code>new_coord</code> or a default name) and added to the dataset as a new coordinate. The new coordinate can also be assigned a custom label (<code>new_label</code>).</p> <p>Parameters:</p> Name Type Description Default <code>str</code> <p>Name of coordinate to convert.</p> required <code>float</code> <p>Value for the plasma electron density used to calculate the skin depth, in \\(\\mathrm{cm}^{-3}\\).</p> required <code>str</code> <p>The name to assign to the new coordinate. If not provided, a default name is generated based on <code>coord</code> and <code>units</code>.</p> <code>None</code> <code>str</code> <p>The label (<code>\"long_name\"</code> attribute) to assign to the new coordinate. If not provided, the label of <code>coord</code> is used, if available.</p> <code>None</code> <code>str</code> <p>The physical units for the new coordinate. Must be either <code>\"m\"</code> for meters or <code>\"cm\"</code> for centimeters.</p> <code>'m'</code> <code>bool</code> <p>If <code>True</code>, the new coordinate is set as the default coordinate for the corresponding dimension, replacing <code>coord</code>.</p> <code>True</code> <p>Returns:</p> Type Description <code>Dataset</code> <p>A new Dataset with the additional converted coordinate.</p> <p>Examples:</p> Converting normalized time units to propagation distance <pre><code>import ozzy as oz\nds = oz.Dataset(data_vars={'var1': [3,4,5]}, coords={'t': [0,1,2]}, dims='t')\nds_m = ds.ozzy.coord_to_physical_distance('t', 1e18, new_coord='z') # z in m\nds_cm = ds.ozzy.coord_to_physical_distance('t', 1e18, units='cm', new_coord='z') # z in cm\n</code></pre> Convert \\(r\\) coordinate to centimeters with new label <pre><code>import ozzy as oz\nimport numpy as np\n\nds = oz.Dataset({'var': np.random.rand(5, 10)},\n                coords={'x2': np.linspace(0, 1, 10)})\nn0 = 1e17  # cm^-3\nds_new = ds.ozzy.coord_to_physical_distance('x2', n0, new_coord='r', units='cm')\n</code></pre>"},{"location":"reference/data-objects/general-methods/#ozzy.accessors.OzzyDataset.coord_to_physical_distance(coord)","title":"<code>coord</code>","text":""},{"location":"reference/data-objects/general-methods/#ozzy.accessors.OzzyDataset.coord_to_physical_distance(n0)","title":"<code>n0</code>","text":""},{"location":"reference/data-objects/general-methods/#ozzy.accessors.OzzyDataset.coord_to_physical_distance(new_coord)","title":"<code>new_coord</code>","text":""},{"location":"reference/data-objects/general-methods/#ozzy.accessors.OzzyDataset.coord_to_physical_distance(new_label)","title":"<code>new_label</code>","text":""},{"location":"reference/data-objects/general-methods/#ozzy.accessors.OzzyDataset.coord_to_physical_distance(units)","title":"<code>units</code>","text":""},{"location":"reference/data-objects/general-methods/#ozzy.accessors.OzzyDataset.coord_to_physical_distance(set_as_default)","title":"<code>set_as_default</code>","text":""},{"location":"reference/data-objects/general-methods/#ozzy.accessors.OzzyDataset.fft","title":"fft","text":"<pre><code>fft(data_var, axes=None, dims=None, **kwargs)\n</code></pre> <p>Calculate the Fast Fourier Transform (FFT) of a variable in a <code>Dataset</code> along specified dimensions. Take FFT of variable in Dataset along specified axes.</p> <p>Warning</p> <p>This method has not been thoroughly checked for accuracy yet. Please double-check your results with a different FFT function.</p> <p>Parameters:</p> Name Type Description Default <code>str</code> <p>The data variable to take FFT of.</p> required <code>list[int]</code> <p>The integer indices of the axes to take FFT along.</p> <code>None</code> <code>list[str]</code> <p>Dimensions along which to compute the FFT. If provided, this takes precedence over <code>axes</code>.</p> <code>None</code> <p>Additional keyword arguments passed to <code>numpy.fft.fftn</code>.</p> <code>{}</code> <p>Returns:</p> Type Description <code>DataArray</code> <p>The FFT result as a new DataArray.</p> <p>Examples:</p> 1D FFT <pre><code>import ozzy as oz\nimport numpy as np\n\n# Create a 1D variable in a [Dataset][xarray.Dataset]\nx = np.linspace(0, 10, 100)\nda = oz.Dataset(data_vars = {'f_x' : np.sin(2 * np.pi * x)}, coords=[x], dims=['x'], pic_data_type='grid')\n\n# Compute the 1D FFT\nda_fft = da.ozzy.fft('f_x', dims=['x'])\n# -&gt; 'fft' took: 0:00:00.085525\n</code></pre> 2D FFT <pre><code>import ozzy as oz\nimport numpy as np\n\n# Create a 2D DataArray\nx = np.linspace(0, 10, 100)\ny = np.linspace(0, 5, 50)\nX, Y = np.meshgrid(x, y)\nda = oz.Dataset(data_vars = {'f_xy': np.sin(2 * np.pi * X) * np.cos(2 * np.pi * Y)},\n        coords=[y, x], dims=['y', 'x'], pic_data_type='grid')\n\n# Compute the 2D FFT\nda_fft = da.ozzy.fft(dims=['x', 'y'])\n# -&gt; 'fft' took: 0:00:00.006278\n</code></pre>"},{"location":"reference/data-objects/general-methods/#ozzy.accessors.OzzyDataset.fft(data_var)","title":"<code>data_var</code>","text":""},{"location":"reference/data-objects/general-methods/#ozzy.accessors.OzzyDataset.fft(axes)","title":"<code>axes</code>","text":""},{"location":"reference/data-objects/general-methods/#ozzy.accessors.OzzyDataset.fft(dims)","title":"<code>dims</code>","text":""},{"location":"reference/data-objects/general-methods/#ozzy.accessors.OzzyDataset.fft(**kwargs)","title":"<code>**kwargs</code>","text":""},{"location":"reference/data-objects/general-methods/#ozzy.accessors.OzzyDataset.save","title":"save","text":"<pre><code>save(path)\n</code></pre> <p>Save data object to an HDF5 (default) or NetCDF file.</p> <p>Parameters:</p> Name Type Description Default <code>str</code> <p>The path to save the file to. Specify the file ending as <code>'.h5'</code> for HDF5 or <code>'.nc'</code> for NetCDF.</p> required <p>Examples:</p> Save empty Dataset <pre><code>import ozzy as oz\nds = oz.Dataset()\nds.ozzy.save('empty_file.h5')\n#  -&gt; Saved file \"empty_file.h5\"\n# -&gt; 'save' took: 0:00:00.197806\n</code></pre>"},{"location":"reference/data-objects/general-methods/#ozzy.accessors.OzzyDataset.save(path)","title":"<code>path</code>","text":""},{"location":"reference/data-objects/backend-methods/","title":"Backend-specific methods","text":""},{"location":"reference/data-objects/backend-methods/#backend-specific-methods","title":"Backend-specific methods","text":"<ul> <li>LCODE</li> <li>OSIRIS</li> <li>ozzy</li> </ul> Note for developers <p>These methods are defined within a mixin class called <code>Methods</code> which should be defined in each backend file (e.g. <code>backends/ozzy_backend.py</code>).</p>"},{"location":"reference/data-objects/backend-methods/lcode/","title":"LCODE","text":""},{"location":"reference/data-objects/backend-methods/lcode/#lcode-specific-methods","title":"LCODE-specific methods","text":"<p>The methods in this page are accessible to a data object if:</p> <pre><code>&lt;data_obj&gt;.attrs['data_origin'] == 'lcode'#(1)!\n</code></pre> <ol> <li><code>&lt;data_obj&gt;</code> may be either <code>ozzy.DataArray</code> or <code>ozzy.Dataset</code></li> </ol>"},{"location":"reference/data-objects/backend-methods/lcode/#ozzy.backends.lcode_backend.Methods.convert_q","title":"convert_q","text":"<pre><code>convert_q(dxi, n0, q_var='q')\n</code></pre> <p>Convert the charge variable to physical units (in units of \\(e\\)).</p> <p>Parameters:</p> Name Type Description Default <code>float</code> <p>The grid spacing in the longitudinal direction in normalized units, i.e., in units of \\(k_p^{-1}\\). or \\(\\mathrm{cm}\\).</p> required <code>float</code> <p>The reference density, in \\(\\mathrm{cm}^{-3}\\).</p> required <code>str</code> <p>Name of the charge density variable.</p> <code>'q'</code> <p>Returns:</p> Type Description <code>None</code> <p>The dataset is modified in place.</p> Notes <p>The charge in physical units (\\(\\mathrm{C}\\)) is obtained by multiplying the normalized charge with the factor \\(\\frac{\\Delta \\hat{\\xi}}{2} \\frac{I_A}{\\omega_p}\\), where \\(\\Delta \\hat{\\xi} = k_p \\Delta \\xi\\) is the normalized longitudinal cell size and \\(I_A\\) is the Alfv\u00e9n current, defined as:</p> \\[ I_A = 4 \\pi \\varepsilon_0 \\frac{m_e c^3}{e} \\approx 17.045 \\ \\mathrm{kA} \\] <p>Note that the charge is given in units of the elementary charge \\(e\\) after this method is applied.</p> <p>Examples:</p> Particle data <pre><code>import ozzy as oz\nfile = 'path/to/particle/file/tb02500.swp'\nds = oz.open('lcode', file)\nds.ozzy.convert_q(dxi=0.01, n0=2e14, q_var='q')\nprint(ds)\n</code></pre>"},{"location":"reference/data-objects/backend-methods/lcode/#ozzy.backends.lcode_backend.Methods.convert_q(dxi)","title":"<code>dxi</code>","text":""},{"location":"reference/data-objects/backend-methods/lcode/#ozzy.backends.lcode_backend.Methods.convert_q(n0)","title":"<code>n0</code>","text":""},{"location":"reference/data-objects/backend-methods/lcode/#ozzy.backends.lcode_backend.Methods.convert_q(q_var)","title":"<code>q_var</code>","text":""},{"location":"reference/data-objects/backend-methods/osiris/","title":"OSIRIS","text":""},{"location":"reference/data-objects/backend-methods/osiris/#osiris-specific-methods","title":"OSIRIS-specific methods","text":"<p>The methods in this page are accessible to a data object if:</p> <pre><code>&lt;data_obj&gt;.attrs['data_origin'] == 'osiris'#(1)!\n</code></pre> <ol> <li><code>&lt;data_obj&gt;</code> may be either <code>ozzy.DataArray</code> or <code>ozzy.Dataset</code></li> </ol> <p>There are currently no OSIRIS-specific methods.</p>"},{"location":"reference/data-objects/backend-methods/ozzy/","title":"ozzy","text":""},{"location":"reference/data-objects/backend-methods/ozzy/#ozzy-specific-methods","title":"ozzy-specific methods","text":"<p>The methods in this page are accessible to a data object if:</p> <pre><code>&lt;data_obj&gt;.attrs['data_origin'] == 'ozzy'#(1)!\n</code></pre> <ol> <li><code>&lt;data_obj&gt;</code> may be either <code>ozzy.DataArray</code> or <code>ozzy.Dataset</code></li> </ol> <p>There are currently no ozzy-specific methods.</p>"},{"location":"reference/data-objects/data-type-methods/","title":"Data-type-specific methods","text":""},{"location":"reference/data-objects/data-type-methods/#data-type-specific-methods","title":"Data-type-specific methods","text":"<ul> <li>Grid data</li> <li>Particle data</li> </ul> Note for developers <p>The following methods are defined within specific mixin classes: <code>GridMixin</code> (<code>grid_mixin.py</code>) and <code>PartMixin</code> (<code>part_mixin.py</code>).</p>"},{"location":"reference/data-objects/data-type-methods/grid-data/","title":"Grid data","text":""},{"location":"reference/data-objects/data-type-methods/grid-data/#methods-for-grid-data","title":"Methods for grid data","text":"<p>The methods in this page are accessible to a data object if:</p> <pre><code>&lt;data_obj&gt;.attrs['pic_data_type'] == 'grid'#(1)!\n</code></pre> <ol> <li><code>&lt;data_obj&gt;</code> may be either <code>ozzy.DataArray</code> or <code>ozzy.Dataset</code></li> </ol>"},{"location":"reference/data-objects/data-type-methods/grid-data/#ozzy.grid_mixin.GridMixin.coords_from_extent","title":"coords_from_extent","text":"<pre><code>coords_from_extent(mapping)\n</code></pre> <p>Add coordinates to DataArray | Dataset based on axis extents.</p> <p>For each axis name and extent tuple in the mapping, get the axis values and assign them to a new coordinate in the data object.</p> <p>Parameters:</p> Name Type Description Default <code>dict[str, tuple[float, float]]</code> <p>Dictionary mapping axis names to (min, max) extents</p> required <p>Returns:</p> Name Type Description <code>obj</code> <code>Same type as self._obj</code> <p>Object with added coordinate values</p> <p>Examples:</p> Example 1 <pre><code>import ozzy as oz\nda = oz.DataArray(np.zeros((4,3)), dims=['x', 'y'], pic_data_type='grid')\nmapping = {'x': (0, 1), 'y': (-1, 2)}\nda = da.ozzy.coords_from_extent(mapping)\n</code></pre>"},{"location":"reference/data-objects/data-type-methods/grid-data/#ozzy.grid_mixin.GridMixin.coords_from_extent(mapping)","title":"<code>mapping</code>","text":""},{"location":"reference/data-objects/data-type-methods/grid-data/#ozzy.grid_mixin.GridMixin.get_bin_edges","title":"get_bin_edges","text":"<pre><code>get_bin_edges(t_var='t')\n</code></pre> <p>Get bin edges along each spatial axis.</p> <p>Calculates bin edges from coordinate values. This is useful for binning operations (see example below).</p> <p>Parameters:</p> Name Type Description Default <code>str</code> <p>Name of time dimension</p> <code>'t'</code> <p>Returns:</p> Type Description <code>list[ndarray]</code> <p>List of bin edges for each spatial axis</p> <p>Examples:</p> Using numpy.histogramdd <pre><code>import numpy as np\nbin_edges = axes_ds.ozzy.get_bin_edges('t')\ndist, edges = np.histogramdd(part_coords, bins=bin_edges, weights=ds_i[w_var])\n</code></pre>"},{"location":"reference/data-objects/data-type-methods/grid-data/#ozzy.grid_mixin.GridMixin.get_bin_edges(t_var)","title":"<code>t_var</code>","text":""},{"location":"reference/data-objects/data-type-methods/grid-data/#ozzy.grid_mixin.GridMixin.get_space_dims","title":"get_space_dims","text":"<pre><code>get_space_dims(t_var='t')\n</code></pre> <p>Get names of spatial dimensions.</p> <p>Returns coordinate names that are not the time dimension.</p> <p>Parameters:</p> Name Type Description Default <code>str</code> <p>Name of time dimension</p> <code>'t'</code> <p>Returns:</p> Type Description <code>list[str]</code> <p>Spatial coordinate names</p> <p>Examples:</p> Example 1 <pre><code>import ozzy as oz\nds = oz.Dataset(...)\nspatial_dims = ds.ozzy.get_space_dims('t')\nprint(spatial_dims)\n</code></pre>"},{"location":"reference/data-objects/data-type-methods/grid-data/#ozzy.grid_mixin.GridMixin.get_space_dims(t_var)","title":"<code>t_var</code>","text":""},{"location":"reference/data-objects/data-type-methods/particle-data/","title":"Particle data","text":""},{"location":"reference/data-objects/data-type-methods/particle-data/#methods-for-particle-data","title":"Methods for particle data","text":"<p>The methods in this page are accessible to a data object when:</p> <pre><code>&lt;data_obj&gt;.attrs['pic_data_type'] == 'part'#(1)!\n</code></pre> <ol> <li><code>&lt;data_obj&gt;</code> may be either <code>ozzy.DataArray</code> or <code>ozzy.Dataset</code></li> </ol>"},{"location":"reference/data-objects/data-type-methods/particle-data/#ozzy.part_mixin.PartMixin.bin_into_grid","title":"bin_into_grid","text":"<pre><code>bin_into_grid(axes_ds, t_var='t', w_var='q', r_var=None)\n</code></pre> <p>Bin particle data into a grid (density distribution).</p> <p>Parameters:</p> Name Type Description Default <code>Dataset</code> <p>Dataset containing grid axes information.</p> Tip <p>The axis information can be created for example with: </p><pre><code>import ozzy as oz\nnx = 200\nny = 150\nxlims = (0.0, 30.0)\nylims = (-4.0, 4.0)\naxes_ds = oz.Dataset(\n    coords={\n        \"x1\": oz.utils.axis_from_extent(nx, xlims),\n        \"x2\": oz.utils.axis_from_extent(ny, ylims),\n    },\n    pic_data_type = \"grid\")\n</code></pre> Or it can be obtained from an existing grid data object with: <pre><code># fields may be an existing Dataset or DataArray\naxes_ds = fields.coords\n</code></pre><p></p> Note about axis attributes <p>By default, the <code>long_name</code> and <code>units</code> attributes of the resulting grid axes are taken from the original particle Dataset. But these attributes are overriden if they are passed along with the <code>axes_ds</code> Dataset.</p> required <code>str</code> <p>Name of the time dimension in the input datasets.</p> <code>'t'</code> <code>str</code> <p>Name of the variable representing particle weights or particle charge.</p> <code>'q'</code> <code>str | None</code> <p>Name of the variable representing particle radial positions. If provided and if one of the <code>axes_ds</code> coordinates is <code>r_var</code>, the particle weights are divided by this variable.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>parts</code> <code>Dataset</code> <p>Dataset containing the charge density distribution on the grid.</p> <p>Raises:</p> Type Description <code>KeyError</code> <p>If no spatial dimensions are found in the input <code>axes_ds</code>.</p> <code>ValueError</code> <p>If the <code>axes_ds</code> argument does not contain grid data.</p> Notes <p>The binned density data is multiplied by a factor that ensures that the total volume integral of the density corresponds to the sum of all particle weights \\(Q_w\\). If \\(w\\) is each particle's weight variable and \\(N_p\\) is the total number of particles, then \\(Q_w\\) is defined as:</p> \\[ Q_w = \\sum_i^{N_p} w_i \\] <p>Note that different simulation codes have different conventions in terms of what \\(Q_w\\) corresponds to.</p> <p>Examples:</p> Usage <pre><code>import ozzy as oz\nimport numpy as np\n\n# Create a sample particle dataset\nparticles = oz.Dataset(\n    {\n        \"x1\": (\"pid\", np.random.uniform(0, 10, 10000)),\n        \"x2\": (\"pid\", np.random.uniform(0, 5, 10000)),\n        \"q\": (\"pid\", np.ones(10000)),\n    },\n    coords={\"pid\": np.arange(10000)},\n    attrs={\"pic_data_type\": \"part\"}\n)\n\n# Create axes for binning\naxes = oz.Dataset(\n    coords={\n        \"x1\": oz.utils.axis_from_extent(100, (0.0, 10.0)),\n        \"x2\": oz.utils.axis_from_extent(50, (0.0, 5.0)),\n    },\n    pic_data_type = \"grid\",\n)\n\n# Bin particles into grid (Cartesian geometry)\ngrid_data = particles.ozzy.bin_into_grid(axes)\n\n# Example 2: Using a different weight variable\nparticles[\"w\"] = (\"pid\", np.random.uniform(0.5, 1.5, 10000))\ngrid_data_weighted = particles.ozzy.bin_into_grid(axes, w_var=\"w\")\n\n# Example 3: Axisymmetric geometry\ngrid_data_axisym = particles.ozzy.bin_into_grid(axes, r_var=\"x2\")\n\n# Example 4: Time-dependent data\ntime_dependent_particles = particles.expand_dims(dim={\"t\": [0, 1, 2]})\ntime_dependent_grid = time_dependent_particles.ozzy.bin_into_grid(axes)\n</code></pre>"},{"location":"reference/data-objects/data-type-methods/particle-data/#ozzy.part_mixin.PartMixin.bin_into_grid(axes_ds)","title":"<code>axes_ds</code>","text":""},{"location":"reference/data-objects/data-type-methods/particle-data/#ozzy.part_mixin.PartMixin.bin_into_grid(t_var)","title":"<code>t_var</code>","text":""},{"location":"reference/data-objects/data-type-methods/particle-data/#ozzy.part_mixin.PartMixin.bin_into_grid(w_var)","title":"<code>w_var</code>","text":""},{"location":"reference/data-objects/data-type-methods/particle-data/#ozzy.part_mixin.PartMixin.bin_into_grid(r_var)","title":"<code>r_var</code>","text":""},{"location":"reference/data-objects/data-type-methods/particle-data/#ozzy.part_mixin.PartMixin.get_emittance","title":"get_emittance","text":"<pre><code>get_emittance(\n    norm_emit=True,\n    axisym=False,\n    p_all_vars=[\"p1\", \"p2\", \"p3\"],\n    x_var=\"x2\",\n    p_var=\"p2\",\n    w_var=\"q\",\n)\n</code></pre> <p>Calculate the RMS beam emittance.</p> <p>Computes the normalized or geometric RMS emittance based on particle positions and momenta. For axisymmetric beams, returns the Lapostolle emittance (see Notes below).</p> <p>Warning</p> <p>This method assumes that the particle dimension is <code>\"pid\"</code>.</p> <p>Parameters:</p> Name Type Description Default <code>bool</code> <p>Whether to calculate normalized emittance (multiplied by \\(\\left&lt; \\beta \\gamma \\right&gt;\\)).</p> <code>True</code> <code>bool</code> <p>If <code>True</code>, calculate Lapostolle emittance for axisymmetric beams</p> <code>False</code> <code>list[str]</code> <p>List of names of momentum components.</p> <p>Note</p> <p>The components should be sorted, e.g. <code>[\"px\", \"py\", \"pz\"]</code>.</p> <p>If <code>axisym=True</code>, only the two first components will be adopted.</p> <code>['p1', 'p2', 'p3']</code> <code>str</code> <p>Variable name for position coordinate in Dataset that should be used for emittance calculation</p> <code>'x2'</code> <code>str</code> <p>Variable name for momentum coordinate in Dataset that should be used for emittance calculation. This argument is only relevant when <code>axisym=False</code>, otherwise it is set to <code>p_all_vars[1]</code>.</p> <code>'p2'</code> <code>str</code> <p>Variable name for particle weights in Dataset</p> <code>'q'</code> <p>Returns:</p> Type Description <code>Dataset</code> <p>Dataset containing the calculated emittance and particle counts for each data point.</p> <p>The emittance variable is named <code>\"emit_norm\"</code> if <code>norm_emit=True</code>, otherwise <code>\"emit\"</code>. Also includes a <code>\"counts\"</code> variable with particle counts.</p> Notes <p>The geometric emittance along a given transverse dimension \\(i\\) is calculated according to:</p> <p>\\(\\epsilon_i = \\sqrt{\\left&lt;x_i^2\\right&gt; \\left&lt;{x'_i}^2\\right&gt; - \\left(x_i x'_i\\right)^2}\\)</p> <p>where \\(x_i\\) is the particle position, and \\(x'_i \\approx p_i / p_\\parallel\\) is the trace for relativistic particles with longitudinal momentum \\(p_\\parallel\\) and transverse momentum \\(p_i \\ll p_\\parallel\\). The angle brackets denote a weighted average over particles.</p> <p>The normalized emittance (<code>norm_emit=True</code>, default) is calculated as:</p> <p>\\(\\epsilon_{N,i} = \\left&lt; \\beta \\gamma \\right&gt; \\ \\epsilon_i\\)</p> <p>where \\(\\beta \\gamma = \\left| \\vec{p} \\right| / (m_\\mathrm{sp} c)\\).</p> <p>For a 2D cylindrical, axisymmetric geometry (<code>axisym=True</code>) this function returns the Lapostolle emittance<sup>1</sup><sup>,</sup><sup>2</sup>, i.e.:</p> <p>\\(\\epsilon = 4 \\ \\epsilon_i\\)</p> <ol> <li> <p>J. D. Lawson, P. M. Lapostolle, and R. L. Gluckstern, Particle Accelerators 5, 61\u201365 (1973),\u00a0\u21a9</p> </li> <li> <p>P. M. Lapostolle, IEEE Transactions on Nuclear Science 18, 1101\u20131104 (1971) \u21a9</p> </li> </ol> <p>Examples:</p> Calculate normalized emittance in 2D cyl. geometry <pre><code>import ozzy as oz\nimport numpy as np\n\n# Create a sample particle dataset\nparticles = oz.Dataset(\n    {\n        \"x\": (\"pid\", np.random.uniform(0, 10, 10000)),\n        \"r\": (\"pid\", np.random.uniform(0, 5, 10000)),\n        \"px\": (\"pid\", np.random.uniform(99, 101, 10000)),\n        \"pr\": (\"pid\", np.random.uniform(-2e-4, 2e-4, 10000)),\n        \"q\": (\"pid\", np.ones(10000)),\n    },\n    coords={\"pid\": np.arange(10000)},\n    attrs={\"pic_data_type\": \"part\"}\n)\n\nemittance = particles.ozzy.get_emittance(axisym=True, x_var=\"r\", p_all_vars=[\"px\", \"pr\"])\n# Returns Dataset with normalized emittance in k_p^(-1) rad\n</code></pre>"},{"location":"reference/data-objects/data-type-methods/particle-data/#ozzy.part_mixin.PartMixin.get_emittance(norm_emit)","title":"<code>norm_emit</code>","text":""},{"location":"reference/data-objects/data-type-methods/particle-data/#ozzy.part_mixin.PartMixin.get_emittance(axisym)","title":"<code>axisym</code>","text":""},{"location":"reference/data-objects/data-type-methods/particle-data/#ozzy.part_mixin.PartMixin.get_emittance(p_all_vars)","title":"<code>p_all_vars</code>","text":""},{"location":"reference/data-objects/data-type-methods/particle-data/#ozzy.part_mixin.PartMixin.get_emittance(x_var)","title":"<code>x_var</code>","text":""},{"location":"reference/data-objects/data-type-methods/particle-data/#ozzy.part_mixin.PartMixin.get_emittance(p_var)","title":"<code>p_var</code>","text":""},{"location":"reference/data-objects/data-type-methods/particle-data/#ozzy.part_mixin.PartMixin.get_emittance(w_var)","title":"<code>w_var</code>","text":""},{"location":"reference/data-objects/data-type-methods/particle-data/#ozzy.part_mixin.PartMixin.get_energy_spectrum","title":"get_energy_spectrum","text":"<pre><code>get_energy_spectrum(\n    axis_ds=None, nbins=None, ene_var=\"ene\", w_var=\"q\"\n)\n</code></pre> <p>Calculate the energy spectrum of particles.</p> <p>This method computes a histogram of particle energy, binning the energy values and summing the associated charge or weighting variable in each bin.</p> <p>Parameters:</p> Name Type Description Default <code>Dataset or None</code> <p>Dataset containing the energy axis to use for binning. Must have <code>ene_var</code> as a coordinate. If <code>None</code>, <code>nbins</code> must be provided.</p> <p>Note</p> <p>If the label and unit attributes exist in <code>axis_ds[ene_var]</code> (<code>'long_name'</code> and <code>'units'</code>, respectively), these attributes are adopted for the output dataset.</p> <code>None</code> <code>int or None</code> <p>Number of bins to use for the energy axis. Only used if <code>axis_ds</code> is <code>None</code>. If <code>None</code>, <code>axis_ds</code> must be provided.</p> <code>None</code> <code>str</code> <p>Name of the energy variable in the dataset, default is <code>\"ene\"</code>.</p> <code>'ene'</code> <code>str</code> <p>Name of the weighting variable (typically charge) in the dataset, default is <code>\"q\"</code>.</p> <code>'q'</code> <p>Returns:</p> Type Description <code>Dataset</code> <p>A new dataset containing the energy spectrum with the following variables: - The weighting variable (e.g., <code>\"q\"</code>) containing the histogram of charge per energy bin - <code>\"counts\"</code> containing the number of particles in each energy bin</p> Notes <p>The absolute value of the weighting variable is used for the calculation.</p> <p>Examples:</p> Basic usage with number of bins <pre><code>import numpy as np\nimport ozzy as oz\n\n# Create a sample particle dataset\nrng = np.random.default_rng()\nds = oz.Dataset(\n    {\n        \"ene\": (\"pid\", rng.normal(100, 5, size=10000) ),\n        \"q\": (\"pid\", rng.random(10000)),\n    },\n    coords={\"pid\": np.arange(10000)},\n    attrs={\"pic_data_type\": \"part\"}\n)\n\n# Get energy spectrum\nspectrum = ds.ozzy.get_energy_spectrum(nbins=100)\n# Plot the result\nspectrum.q.plot()\n</code></pre> Using a custom energy axis <pre><code>import numpy as np\nimport ozzy as oz\n\n# Create a sample particle dataset\nrng = np.random.default_rng()\nds = oz.Dataset(\n    {\n        \"p1\": (\"pid\", rng.lognormal(3.0, 1.0, size=10000) ),\n        \"weight\": (\"pid\", rng.random(10000)),\n    },\n    coords={\"pid\": np.arange(10000)},\n    attrs={\"pic_data_type\": \"part\"}\n)\n\n# Create a custom logarithmic energy axis\nenergy_axis = np.logspace(-1, 3, 50)  # 50 points from 0.1 to 1000\naxis_ds = oz.Dataset(coords={\"p1\": energy_axis}, pic_data_type=\"grid\")\naxis_ds[\"p1\"].attrs[\"long_name\"] = r\"$p_1$\"\naxis_ds[\"p1\"].attrs[\"units\"] = r\"$m_\\mathrm{sp} c$\"\n\n# Get energy spectrum using this axis\nspectrum = ds.ozzy.get_energy_spectrum(axis_ds=axis_ds, ene_var=\"p1\", w_var=\"weight\")\n# Plot the result\nspectrum[\"weight\"].plot(marker=\".\")\n# Spectrum now contains the summed weights in each logarithmic energy bin\n</code></pre>"},{"location":"reference/data-objects/data-type-methods/particle-data/#ozzy.part_mixin.PartMixin.get_energy_spectrum(axis_ds)","title":"<code>axis_ds</code>","text":""},{"location":"reference/data-objects/data-type-methods/particle-data/#ozzy.part_mixin.PartMixin.get_energy_spectrum(nbins)","title":"<code>nbins</code>","text":""},{"location":"reference/data-objects/data-type-methods/particle-data/#ozzy.part_mixin.PartMixin.get_energy_spectrum(ene_var)","title":"<code>ene_var</code>","text":""},{"location":"reference/data-objects/data-type-methods/particle-data/#ozzy.part_mixin.PartMixin.get_energy_spectrum(w_var)","title":"<code>w_var</code>","text":""},{"location":"reference/data-objects/data-type-methods/particle-data/#ozzy.part_mixin.PartMixin.get_phase_space","title":"get_phase_space","text":"<pre><code>get_phase_space(\n    vars,\n    extents=None,\n    nbins=200,\n    r_var=None,\n    t_var=\"t\",\n    w_var=\"q\",\n)\n</code></pre> <p>Generate a phase space grid from particle data.</p> <p>Creates a gridded dataset by depositing particle quantities onto a 2D phase space.</p> <p>Parameters:</p> Name Type Description Default <code>list[str]</code> <p>Variables to deposit onto phase space.</p> required <code>dict[str, tuple[float, float]]</code> <p>Minimum and maximum extent for each variable. If not specified, extents are calculated from the data.</p> <code>None</code> <code>int | dict[str, int]</code> <p>Number of bins for each variable. If <code>int</code>, the same number of bins is used for all variables.</p> <code>200</code> <code>str | None</code> <p>Name of the variable representing particle radial positions. If provided and if one of <code>vars</code> is <code>r_var</code>, the particle weights are divided by this variable.</p> <code>None</code> <code>str</code> <p>Name of the time dimension in the input datasets.</p> <code>'t'</code> <code>str</code> <p>Name of the variable representing particle weights or particle charge.</p> <code>'q'</code> <p>Returns:</p> Type Description <code>Dataset</code> <p>Dataset with phase space data.</p> <p>Examples:</p> Transverse phase space <pre><code>import ozzy as oz\nimport numpy as np\n\n# Create a sample particle dataset\nds = oz.Dataset(\n    {\n        \"x1\": (\"pid\", np.random.rand(10000)),\n        \"x2\": (\"pid\", np.random.rand(10000)),\n        \"p1\": (\"pid\", np.random.rand(10000)),\n        \"p2\": (\"pid\", np.random.rand(10000)),\n        \"q\": (\"pid\", np.ones(10000)),\n    },\n    coords={\"pid\": np.arange(10000)},\n    pic_data_type=\"part\",\n    data_origin=\"ozzy\",\n)\n\nds_ps = ds.ozzy.get_phase_space(['p2', 'x2'], nbins=100)\n</code></pre>"},{"location":"reference/data-objects/data-type-methods/particle-data/#ozzy.part_mixin.PartMixin.get_phase_space(vars)","title":"<code>vars</code>","text":""},{"location":"reference/data-objects/data-type-methods/particle-data/#ozzy.part_mixin.PartMixin.get_phase_space(extents)","title":"<code>extents</code>","text":""},{"location":"reference/data-objects/data-type-methods/particle-data/#ozzy.part_mixin.PartMixin.get_phase_space(nbins)","title":"<code>nbins</code>","text":""},{"location":"reference/data-objects/data-type-methods/particle-data/#ozzy.part_mixin.PartMixin.get_phase_space(r_var)","title":"<code>r_var</code>","text":""},{"location":"reference/data-objects/data-type-methods/particle-data/#ozzy.part_mixin.PartMixin.get_phase_space(t_var)","title":"<code>t_var</code>","text":""},{"location":"reference/data-objects/data-type-methods/particle-data/#ozzy.part_mixin.PartMixin.get_phase_space(w_var)","title":"<code>w_var</code>","text":""},{"location":"reference/data-objects/data-type-methods/particle-data/#ozzy.part_mixin.PartMixin.get_slice_emittance","title":"get_slice_emittance","text":"<pre><code>get_slice_emittance(\n    axis_ds=None,\n    nbins=None,\n    norm_emit=True,\n    axisym=False,\n    p_all_vars=[\"p1\", \"p2\", \"p3\"],\n    min_count=None,\n    slice_var=\"x1_box\",\n    x_var=\"x2\",\n    p_var=\"p2\",\n    w_var=\"q\",\n)\n</code></pre> <p>Calculate the RMS slice emittance of particle data.</p> <p>This method computes the slice emittance by binning particles along a specified variable and calculating the RMS emittance (normalized or geometric) for each slice. For axisymmetric beams, returns the Lapostolle emittance (see Notes below).</p> <p>Warning</p> <p>This method assumes that the particle dimension is <code>\"pid\"</code>.</p> <p>Parameters:</p> Name Type Description Default <code>Dataset or None</code> <p>Dataset containing coordinate information for binning. If provided, bin edges are extracted from this dataset. Either <code>axis_ds</code> or <code>nbins</code> must be specified.</p> <p>Note</p> <p>If the label and unit attributes exist in <code>axis_ds[slice_var]</code> (<code>'long_name'</code> and <code>'units'</code>, respectively), these attributes are adopted for the output dataset.</p> <code>None</code> <code>int or None</code> <p>Number of bins to use for slicing. Either <code>axis_ds</code> or <code>nbins</code> must be specified.</p> <code>None</code> <code>bool</code> <p>Whether to calculate normalized emittance (multiplied by \\(\\left&lt; \\beta \\gamma \\right&gt;\\)).</p> <code>True</code> <code>bool</code> <p>Whether to apply Lapostolle factor of 4.</p> <code>False</code> <code>list[str]</code> <p>List of names of momentum components.</p> <p>Note</p> <p>The components should be sorted, e.g. <code>[\"px\", \"py\", \"pz\"]</code>.</p> <p>If <code>axisym=True</code>, only the two first components will be adopted.</p> <code>['p1', 'p2', 'p3']</code> <code>int or None</code> <p>Minimum number of particles required in each bin for valid calculation.</p> <code>None</code> <code>str</code> <p>Variable name to use for slicing/binning the particles.</p> <code>'x1_box'</code> <code>str</code> <p>Variable name for the transverse position coordinate that should be used for emittance calculation.</p> <code>'x2'</code> <code>str</code> <p>Variable name for the transverse momentum coordinate that should be used for emittance calculation. This argument is only relevant when <code>axisym=False</code>, otherwise it is set to <code>p_all_vars[1]</code>.</p> <code>'p2'</code> <code>str</code> <p>Variable name for the particle weights/charges.</p> <code>'q'</code> <p>Returns:</p> Type Description <code>Dataset</code> <p>Dataset containing the calculated slice emittance and particle counts per bin.</p> <p>The emittance variable is named <code>\"slice_emit_norm\"</code> if <code>norm_emit=True</code>, otherwise <code>\"slice_emit\"</code>. Also includes a <code>\"counts\"</code> variable with particle counts per bin.</p> Notes <p>Particles are binned along the specified <code>slice_var</code> variable, and the emittance is computed for each binned ensemble.</p> <p>The geometric emittance along a given transverse dimension \\(i\\) is calculated according to:</p> <p>\\(\\epsilon_i = \\sqrt{\\left&lt;x_i^2\\right&gt; \\left&lt;{x'_i}^2\\right&gt; - \\left(x_i x'_i\\right)^2}\\)</p> <p>where \\(x_i\\) is the particle position, and \\(x'_i \\approx p_i / p_\\parallel\\) is the trace for relativistic particles with longitudinal momentum \\(p_\\parallel\\) and transverse momentum \\(p_i \\ll p_\\parallel\\). The angle brackets denote a weighted average over particles.</p> <p>The normalized emittance (<code>norm_emit=True</code>, default) is calculated as:</p> <p>\\(\\epsilon_{N,i} = \\left&lt; \\beta \\gamma \\right&gt; \\ \\epsilon_i\\)</p> <p>where \\(\\beta \\gamma = \\left| \\vec{p} \\right| / (m_\\mathrm{sp} c)\\).</p> <p>For a 2D cylindrical, axisymmetric geometry (<code>axisym=True</code>) this function returns the Lapostolle emittance<sup>1</sup><sup>,</sup><sup>2</sup>, i.e.:</p> <p>\\(\\epsilon = 4 \\ \\epsilon_i\\)</p> <ol> <li> <p>J. D. Lawson, P. M. Lapostolle, and R. L. Gluckstern, Particle Accelerators 5, 61\u201365 (1973),\u00a0\u21a9</p> </li> <li> <p>P. M. Lapostolle, IEEE Transactions on Nuclear Science 18, 1101\u20131104 (1971) \u21a9</p> </li> </ol> <p>Examples:</p> Calculate normalized slice emittance in 2D cyl. geometry <pre><code>import ozzy as oz\nimport numpy as np\n\n# Create a sample particle dataset\nparticles = oz.Dataset(\n    {\n        \"x\": (\"pid\", np.random.uniform(0, 10, 10000)),\n        \"r\": (\"pid\", np.random.uniform(0, 5, 10000)),\n        \"px\": (\"pid\", np.random.uniform(99, 101, 10000)),\n        \"pr\": (\"pid\", np.random.uniform(-2e-4, 2e-4, 10000)),\n        \"q\": (\"pid\", np.ones(10000)),\n    },\n    coords={\"pid\": np.arange(10000)},\n    attrs={\"pic_data_type\": \"part\"}\n)\n\n# Longitudinal axis along which to bin\naxis = oz.utils.axis_from_extent(500, (0,10))\naxis_ds = oz.Dataset({\"x\": axis}, pic_data_type = \"grid\")\n\nemittance = particles.ozzy.get_slice_emittance(axis_ds=axis_ds, axisym=True, slice_var=\"x\", x_var=\"r\", p_all_vars=[\"px\",\"pr\"])\n# Returns Dataset with normalized emittance in k_p^(-1) rad\n</code></pre>"},{"location":"reference/data-objects/data-type-methods/particle-data/#ozzy.part_mixin.PartMixin.get_slice_emittance(axis_ds)","title":"<code>axis_ds</code>","text":""},{"location":"reference/data-objects/data-type-methods/particle-data/#ozzy.part_mixin.PartMixin.get_slice_emittance(nbins)","title":"<code>nbins</code>","text":""},{"location":"reference/data-objects/data-type-methods/particle-data/#ozzy.part_mixin.PartMixin.get_slice_emittance(norm_emit)","title":"<code>norm_emit</code>","text":""},{"location":"reference/data-objects/data-type-methods/particle-data/#ozzy.part_mixin.PartMixin.get_slice_emittance(axisym)","title":"<code>axisym</code>","text":""},{"location":"reference/data-objects/data-type-methods/particle-data/#ozzy.part_mixin.PartMixin.get_slice_emittance(p_all_vars)","title":"<code>p_all_vars</code>","text":""},{"location":"reference/data-objects/data-type-methods/particle-data/#ozzy.part_mixin.PartMixin.get_slice_emittance(min_count)","title":"<code>min_count</code>","text":""},{"location":"reference/data-objects/data-type-methods/particle-data/#ozzy.part_mixin.PartMixin.get_slice_emittance(slice_var)","title":"<code>slice_var</code>","text":""},{"location":"reference/data-objects/data-type-methods/particle-data/#ozzy.part_mixin.PartMixin.get_slice_emittance(x_var)","title":"<code>x_var</code>","text":""},{"location":"reference/data-objects/data-type-methods/particle-data/#ozzy.part_mixin.PartMixin.get_slice_emittance(p_var)","title":"<code>p_var</code>","text":""},{"location":"reference/data-objects/data-type-methods/particle-data/#ozzy.part_mixin.PartMixin.get_slice_emittance(w_var)","title":"<code>w_var</code>","text":""},{"location":"reference/data-objects/data-type-methods/particle-data/#ozzy.part_mixin.PartMixin.get_weighted_median","title":"get_weighted_median","text":"<pre><code>get_weighted_median(var, w_var='q', t_var='t')\n</code></pre> <p>Calculate the weighted median of a variable in the particle dataset.</p> <p>This method computes the median of <code>var</code> weighted by the values in <code>w_var</code>, for each value in the time variable <code>t_var</code> (if the <code>t_var</code> dimension exists).</p> <p>Parameters:</p> Name Type Description Default <code>str</code> <p>Name of the variable for which to calculate the weighted median.</p> required <code>str</code> <p>Name of the weighting variable, by default <code>\"q\"</code>. The absolute value of this variable is used for weighting.</p> <code>'q'</code> <code>str</code> <p>Name of the time dimension to iterate over, by default <code>\"t\"</code>. If this dimension exists in the dataset, a weighted median is calculated for each time step.</p> <code>'t'</code> <p>Returns:</p> Type Description <code>DataArray</code> <p>DataArray containing the weighted median value(s). If <code>t_var</code> is present in the dataset, the result will have the same <code>t_var</code> dimension.</p> Notes <p>The weighted median is calculated by: 1. Sorting the data according to the variable of interest 2. Computing the cumulative sum of weights 3. Finding the point where the cumulative sum of weights reaches half of the total weight</p> <p>For an odd number of observations, the midpoint value is used directly. For an even number, the average of the two middle values is used.</p> <p>Examples:</p> Basic usage with particle energy <pre><code>import numpy as np\nimport ozzy as oz\n\n# Create a sample particle dataset\nrng = np.random.default_rng(seed=42)\nds = oz.Dataset(\n    {\n        \"energy\": (\"pid\", rng.normal(100, 20, size=1000)),\n        \"q\": (\"pid\", rng.random(1000)),\n    },\n    coords={\"pid\": np.arange(1000)},\n    pic_data_type = \"part\",\n)\n\n# Calculate the weighted median of energy\nmedian_energy = ds.ozzy.get_weighted_median(var=\"energy\")\nprint(f\"Weighted median energy: {median_energy.values:.2f}\")\n# Weighted median energy: ~100.00 (exact value will vary)\n</code></pre> Time-dependent weighted median <pre><code>import numpy as np\nimport ozzy as oz\n\n# Create a sample particle dataset with time dimension\nrng = np.random.default_rng(seed=42)\ntimes = np.linspace(0, 10, 5)\nenergies = np.zeros((5, 100))\n\n# Create time-dependent energies\nfor i, t in enumerate(times):\n    energies[i] = rng.normal(100 + t*10, 20, size=100)\n\nds = oz.Dataset(\n    {\n        \"energy\": ([\"t\", \"pid\"], energies),\n        \"q\": ([\"t\", \"pid\"], rng.random((5, 100))),\n    },\n    coords={\n        \"t\": times,\n        \"pid\": np.arange(100)\n    },\n    pic_data_type = \"part\",\n)\n\n# Calculate the time-dependent weighted median of energy\nmedian_energy = ds.ozzy.get_weighted_median(var=\"energy\")\n\n# Plot the result\nmedian_energy.plot()\n# The plot will show the weighted median energy increasing over time\n</code></pre>"},{"location":"reference/data-objects/data-type-methods/particle-data/#ozzy.part_mixin.PartMixin.get_weighted_median(var)","title":"<code>var</code>","text":""},{"location":"reference/data-objects/data-type-methods/particle-data/#ozzy.part_mixin.PartMixin.get_weighted_median(w_var)","title":"<code>w_var</code>","text":""},{"location":"reference/data-objects/data-type-methods/particle-data/#ozzy.part_mixin.PartMixin.get_weighted_median(t_var)","title":"<code>t_var</code>","text":""},{"location":"reference/data-objects/data-type-methods/particle-data/#ozzy.part_mixin.PartMixin.mean_std","title":"mean_std","text":"<pre><code>mean_std(vars, axes_ds, expand_time=True, axisym=False)\n</code></pre> <p>Calculate mean and standard deviation of variables.</p> <p>Bins the particle data onto the grid specified by <code>axes_ds</code> and calculates the mean and standard deviation for each bin.</p> <p>Parameters:</p> Name Type Description Default <code>str | list[str]</code> <p>The variable(s) for which to calculate statistics.</p> required <code>Dataset | DataArray | Coordinates</code> <p>Data object containing the axes to use for the calculation (as xarray coordinates).</p> <p>Tip</p> <p>The axes object can be taken from an existing Dataset or DataArray via <code>axes_ds = &lt;data_obj&gt;.coords</code>.</p> required <code>bool</code> <p>If <code>True</code>, statistics are calculated separately for each timestep.</p> <code>True</code> <code>bool</code> <p>If <code>True</code>, azimuthal symmetry is assumed.</p> <code>False</code> <p>Returns:</p> Type Description <code>Dataset</code> <p>Dataset containing the calculated mean and standard deviation of the particle variables.</p> <p>Examples:</p> Get mean and std of <code>'x2'</code> and <code>'p2'</code> <pre><code>import ozzy as oz\nimport numpy as np\n\n# Create a sample particle dataset\nds = oz.Dataset(\n    {\n        \"x1\": (\"pid\", np.random.rand(10000)),\n        \"x2\": (\"pid\", np.random.rand(10000)),\n        \"p1\": (\"pid\", np.random.rand(10000)),\n        \"p2\": (\"pid\", np.random.rand(10000)),\n        \"q\": (\"pid\", np.ones(10000)),\n    },\n    coords={\"pid\": np.arange(10000)},\n    pic_data_type=\"part\",\n    data_origin=\"ozzy\",\n)\n\n# Create axes for binning\naxes_ds = oz.Dataset(\n    coords={\n        \"x1\": np.linspace(0, 1, 21),\n    },\n    pic_data_type=\"grid\",\n    data_origin=\"ozzy\",\n)\n\n# Calculate mean and standard deviation\nds_mean_std = ds.ozzy.mean_std([\"x2\", \"p2\"], axes_ds)\n</code></pre>"},{"location":"reference/data-objects/data-type-methods/particle-data/#ozzy.part_mixin.PartMixin.mean_std(vars)","title":"<code>vars</code>","text":""},{"location":"reference/data-objects/data-type-methods/particle-data/#ozzy.part_mixin.PartMixin.mean_std(axes_ds)","title":"<code>axes_ds</code>","text":""},{"location":"reference/data-objects/data-type-methods/particle-data/#ozzy.part_mixin.PartMixin.mean_std(expand_time)","title":"<code>expand_time</code>","text":""},{"location":"reference/data-objects/data-type-methods/particle-data/#ozzy.part_mixin.PartMixin.mean_std(axisym)","title":"<code>axisym</code>","text":""},{"location":"reference/data-objects/data-type-methods/particle-data/#ozzy.part_mixin.PartMixin.sample_particles","title":"sample_particles","text":"<pre><code>sample_particles(n)\n</code></pre> <p>Downsample a particle Dataset by randomly choosing particles.</p> <p>Parameters:</p> Name Type Description Default <code>int</code> <p>Number of particles to sample.</p> required <p>Returns:</p> Type Description <code>Dataset</code> <p>Dataset with sampled particles.</p> <p>Examples:</p> Sample 1000 particles <pre><code>import ozzy as oz\nimport numpy as np\n\n\n# Create a sample particle dataset\nds = oz.Dataset(\n    {\n        \"x1\": (\"pid\", np.random.rand(10000)),\n        \"x2\": (\"pid\", np.random.rand(10000)),\n        \"p1\": (\"pid\", np.random.rand(10000)),\n        \"p2\": (\"pid\", np.random.rand(10000)),\n        \"q\": (\"pid\", np.ones(10000)),\n    },\n    coords={\"pid\": np.arange(10000)},\n    pic_data_type=\"part\",\n    data_origin=\"ozzy\",\n)\n\n# Sample 1000 particles\nds_small = ds.ozzy.sample_particles(1000)\nprint(len(ds_small.pid))\n# 1000\n\n# Try to sample more particles than available\nds_all = ds.ozzy.sample_particles(20000)\n# WARNING: number of particles to be sampled is larger than total particles. Proceeding without any sampling.\nprint(len(ds_all.pid))\n# 10000\n</code></pre>"},{"location":"reference/data-objects/data-type-methods/particle-data/#ozzy.part_mixin.PartMixin.sample_particles(n)","title":"<code>n</code>","text":""},{"location":"release-notes/","title":"Release Notes","text":""},{"location":"release-notes/#release-notes","title":"Release Notes","text":""},{"location":"release-notes/#version-201","title":"Version 2.0.1","text":"<p>Released 05-09-2025 </p>"},{"location":"release-notes/#bug-fixes","title":"Bug Fixes","text":"<ul> <li><code>bcd0bf6</code>: Bug in helper function <code>ozzy.utils.prep_file_input</code> was preventing ozzy from finding files to open, raising <code>filenotfounderror</code></li> </ul>"},{"location":"release-notes/#version-200","title":"Version 2.0.0","text":"<p>Released 29-08-2025 </p>"},{"location":"release-notes/#bug-fixes_1","title":"Bug Fixes","text":"<ul> <li> <p><code>6404186</code>: Fix bug in <code>bin_into_grid</code> (and <code>get_phase_space</code>, which depends on it) for axisymmetric data</p> <p>This bug was possibly producing incorrect results when <code>bin_into_grid</code> or <code>get_phase_space</code> were called on an axisymmetric particle dataset, and where all of these conditions were met:</p> <ul> <li> <p><code>r_var</code> was provided as an argument (other than <code>None</code>)</p> </li> <li> <p>for <code>get_phase_space</code>, the argument <code>axisym</code> was set to <code>True</code></p> </li> <li> <p>the radial variable <code>r_var</code> was not part of either the <code>axes_ds</code> (for <code>bin_into_grid</code>) or <code>vars</code> (for <code>get_phase_space</code>) argument</p> </li> </ul> </li> </ul>"},{"location":"release-notes/#documentation","title":"Documentation","text":"<ul> <li> <p><code>4ff3d2e</code>: Restructure the \"data object methods\" section of the code reference and other small updates</p> </li> <li> <p><code>6cec2a7</code>: Improve example of <code>convert_q</code> method</p> </li> </ul>"},{"location":"release-notes/#features","title":"Features","text":"<ul> <li> <p><code>7855a10</code>: Add function to get the weighted median of some variable in a particle dataset</p> <p>Particle data from PIC codes is often weighted (often in the form of an individual macroparticle \"charge\"), which means that the calculation of a median value is not as straightforward as for other discrete and unweighted data. This method ensures that a median value can be calculated correctly, taking the macroparticle weights into account.</p> <p>This function can be called as a particle method, e.g. <code>part_ds.ozzy.get_weighted_mean</code>, where <code>part_ds</code> is an ozzy particle Dataset object (i.e., with attribute <code>pic_data_type = \"part\"</code>).</p> </li> </ul>"},{"location":"release-notes/#refactoring","title":"Refactoring","text":"<ul> <li> <p><code>cb5973f</code>: Make all arguments for variable names consistent</p> <p>Some functions have input arguments where the name of a certain variable can be specificied. The naming for this type of argument has been made consistent across the code. For example, the arguments <code>time_dim</code> or <code>tvar</code> have been renamed to <code>t_var</code>.</p> <p>Breaking change: <code>TypeError</code> may be raised when some functions are called using the old argument names</p> <p>Please make sure to update your scripts with the new arguments (e.g. <code>w_var</code> instead of <code>wvar</code>).</p> </li> <li> <p><code>f668c5d</code>: Add hidden method <code>_contains_datavars</code> to ozzy dataset objects to simplify input validation in other parts of the code</p> <p>Given a list of variable names, this method checks whether each variable exists in the Dataset as a data variable and raises a <code>KeyError</code> if it doesn't. This is useful when implementing new functions that require some data variables as input (for example <code>get_emittance</code> or <code>get_energy_spectrum</code>).</p> </li> </ul>"},{"location":"release-notes/#version-134","title":"Version 1.3.4","text":"<p>Released 26-08-2025 </p>"},{"location":"release-notes/#bug-fixes_2","title":"Bug Fixes","text":"<ul> <li> <p><code>d3403f1</code>: Turn off <code>savefig.transparent</code> in default <code>rcparams</code> when using the <code>movie</code> function</p> <p>Each frame was previously being saved with a transparent background, which meant that the movies produced with <code>ozzy.plot.movie</code> were superimposing all of the frames.</p> </li> </ul>"},{"location":"release-notes/#version-133","title":"Version 1.3.3","text":"<p>Released 29-07-2025 </p>"},{"location":"release-notes/#bug-fixes_3","title":"Bug Fixes","text":"<ul> <li><code>3675499</code>: Correct a bug in <code>get_energy_spectrum</code></li> </ul>"},{"location":"release-notes/#version-132","title":"Version 1.3.2","text":"<p>Released 29-07-2025 </p>"},{"location":"release-notes/#bug-fixes_4","title":"Bug Fixes","text":"<ul> <li><code>6effaee</code>: Correct a couple of bugs in the calculation of the normalized emittance</li> </ul>"},{"location":"release-notes/#version-131","title":"Version 1.3.1","text":"<p>Released 23-07-2025 </p>"},{"location":"release-notes/#bug-fixes_5","title":"Bug Fixes","text":"<ul> <li> <p><code>8a02447</code>: Error when trying to save the output of <code>get_slice_emittance</code> or <code>get_energy_spectrum</code></p> <p>These particle methods use a special binning and grouping function (<code>flox.xarray.xarray_reduce</code>) for increased efficiency. However, this function creates a coordinate for the binned variable with the data type <code>pandas.Interval</code>, which makes it impossible to save the data with <code>ds.ozzy.save</code>. The binned coordinate is now converted into a normal <code>numpy</code> array, using the midpoints of each interval element.</p> </li> </ul>"},{"location":"release-notes/#documentation_1","title":"Documentation","text":"<ul> <li><code>3242468</code>: Add docstring to new utility function <code>convert_interval_to_mid</code></li> </ul>"},{"location":"release-notes/#refactoring_1","title":"Refactoring","text":"<ul> <li> <p><code>4fc223d</code>: Add timing information to several particle methods</p> <p>The particle methods get_phase_space, get_emittance, get_slice_emittance, get_energy_spectrum now print the time taken to complete.</p> </li> <li> <p><code>ef3420f</code>: Add timing information to several particle methods</p> <p>The particle methods <code>get_phase_space</code>, <code>get_emittance</code>, <code>get_slice_emittance</code>, <code>get_energy_spectrum</code> now print the time taken to complete.</p> </li> </ul>"},{"location":"release-notes/#version-130","title":"Version 1.3.0","text":"<p>Released 16-07-2025 </p>"},{"location":"release-notes/#bug-fixes_6","title":"Bug Fixes","text":"<ul> <li> <p><code>2f8993b</code>: Use absolute value of weight variable for <code>ozzy.plot.hist</code> and <code>ozzy.plot.hist_proj</code></p> <p>The weighting variable in data objects is often a charge (e.g. <code>do['q']</code>), which means that it has a charge sign. This would show up in histograms as negative counts.</p> </li> <li> <p><code>ade7881</code>: Accept filenames for beamfiles (and plasma and fields files) with more flexible patterns</p> <p>Now accepts the regex filename pattern <code>\"beamfile\\w*\\.bin\"</code> instead of <code>\"beamfile.bin\"</code>. The same applies to <code>plasma.bin</code> and <code>fields.bin</code> files.</p> <p>Before:</p> <p>\u2705 <code>beamfile.bin</code></p> <p>\u274c <code>beamfile_changed.bin</code></p> <p>\u274c <code>beamfile2.bin</code></p> <p>Now:</p> <p>\u2705 <code>beamfile.bin</code></p> <p>\u2705 <code>beamfile_changed.bin</code></p> <p>\u2705 <code>beamfile2.bin</code></p> </li> <li> <p><code>cdf5a87</code>: Bug in <code>bin_into_grid</code> where the time dimension was hardcoded as <code>&amp;#34;t&amp;#34;</code></p> </li> </ul>"},{"location":"release-notes/#documentation_2","title":"Documentation","text":"<ul> <li> <p><code>411f68d</code>: Hide toc sidebar in homepage of documentation while keeping the margins</p> <p>Solution adopted from this StackOverflow answer.</p> </li> <li> <p><code>8e3538f</code>: Update changelog manually</p> </li> </ul>"},{"location":"release-notes/#features_1","title":"Features","text":"<ul> <li> <p><code>cfa8949</code>: Add energy spectrum calculation</p> <p>Add <code>get_energy_spectrum</code> method to particle datasets, which calculates energy histograms with proper binning and attribute handling. See documentation for examples of usage.</p> </li> <li> <p><code>a542991</code>: Add method to get the slice emittance <code>get_slice_emittance</code></p> <p>Includes some changes to the <code>get_emittance</code> method and its documentation. It is now possible to choose between the normalized and geometric emittance, for example.</p> </li> </ul>"},{"location":"release-notes/#refactoring_2","title":"Refactoring","text":"<ul> <li> <p><code>10eef35</code>: The output of <code>get_slice_emittance</code> now adopts any label and units attributes provided with <code>axis_ds</code></p> </li> <li> <p><code>4d876ca</code>: Add utility function to insert string at a given index</p> </li> <li> <p><code>fb3cc12</code>: Add <code>time_dim</code> and <code>weight_var</code> arguments in <code>get_phase_space</code></p> <p>The function <code>get_phase_space</code> calls <code>bin_into_grid</code>, which was setting some defaults for the <code>time_dim</code> and <code>weight_var</code> arguments. This is not the case anymore.</p> </li> <li> <p><code>f0e45a7</code>: Add <code>time_dim</code> and <code>weight_var</code> arguments in <code>get_phase_space</code></p> <p>The function <code>get_phase_space</code> calls <code>bin_into_grid</code>, which was setting some defaults for the <code>time_dim</code> and <code>weight_var</code> arguments. This is not the case anymore.</p> </li> </ul>"},{"location":"release-notes/#version-1210","title":"Version 1.2.10","text":"<p>Released 23-06-2025 </p>"},{"location":"release-notes/#bug-fixes_7","title":"Bug Fixes","text":"<ul> <li> <p><code>3953907</code>: Use absolute value of weight variable for <code>ozzy.plot.hist</code> and <code>ozzy.plot.hist_proj</code></p> <p>The weighting variable in data objects is often a charge (e.g. <code>do['q']</code>), which means that it has a charge sign. This would show up in histograms as negative counts.</p> </li> </ul>"},{"location":"release-notes/#documentation_3","title":"Documentation","text":"<ul> <li><code>0e9829a</code>: Update changelog manually</li> </ul>"},{"location":"release-notes/#version-129","title":"Version 1.2.9","text":"<p>Released 20-06-2025 </p>"},{"location":"release-notes/#bug-fixes_8","title":"Bug Fixes","text":"<ul> <li> <p><code>f25affb</code>: Accept filenames for beamfiles (and plasma and fields files) with more flexible patterns</p> <p>Now accepts the regex filename pattern <code>\"beamfile\\w*\\.bin\"</code> instead of <code>\"beamfile.bin\"</code>. The same applies to <code>plasma.bin</code> and <code>fields.bin</code> files.</p> <p>Before:</p> <p>\u2705 <code>beamfile.bin</code></p> <p>\u274c <code>beamfile_changed.bin</code></p> <p>\u274c <code>beamfile2.bin</code></p> <p>Now:</p> <p>\u2705 <code>beamfile.bin</code></p> <p>\u2705 <code>beamfile_changed.bin</code></p> <p>\u2705 <code>beamfile2.bin</code></p> </li> </ul>"},{"location":"release-notes/#version-128","title":"Version 1.2.8","text":"<p>Released 20-06-2025 </p>"},{"location":"release-notes/#bug-fixes_9","title":"Bug Fixes","text":"<ul> <li><code>4cc2da9</code>: Bug in <code>bin_into_grid</code> where the time dimension was hardcoded as <code>&amp;#34;t&amp;#34;</code></li> </ul>"},{"location":"release-notes/#version-127","title":"Version 1.2.7","text":"<p>Released 23-05-2025 </p>"},{"location":"release-notes/#bug-fixes_10","title":"Bug Fixes","text":"<ul> <li> <p><code>741f0af</code>: Ability to use paul tol's reversed colormaps by appending <code>&amp;#39;_r&amp;#39;</code></p> </li> <li> <p><code>d5bcdcb</code>: Assign <code>dtype</code> to concatenated data before chunking</p> </li> </ul>"},{"location":"release-notes/#version-126","title":"Version 1.2.6","text":"<p>Released 08-05-2025 </p>"},{"location":"release-notes/#bug-fixes_11","title":"Bug Fixes","text":"<ul> <li> <p><code>d5d84f2</code>: Make sure that raw files containing no particles at all can still be assigned times and concatenated</p> </li> <li> <p><code>824cfed</code>: Bug for raw files with no particle tag data</p> </li> </ul>"},{"location":"release-notes/#version-125","title":"Version 1.2.5","text":"<p>Released 30-04-2025 </p>"},{"location":"release-notes/#bug-fixes_12","title":"Bug Fixes","text":"<ul> <li><code>08ad9a6</code>: Fix bug that was causing an error when <code>hist</code> or <code>hist_proj</code> were called with <code>weight_var = none</code></li> </ul>"},{"location":"release-notes/#version-124","title":"Version 1.2.4","text":"<p>Released 30-04-2025 </p>"},{"location":"release-notes/#bug-fixes_13","title":"Bug Fixes","text":"<ul> <li><code>89eac7e</code>: Change algorithm so that spatially averaged (<code>savg</code>) grid data can be read</li> </ul>"},{"location":"release-notes/#refactoring_3","title":"Refactoring","text":"<ul> <li> <p><code>83b988e</code>: Tweaked some parameters in <code>local_maxima_and_zero_crossings</code> to improve peak and zero finding</p> </li> <li> <p><code>0ff220f</code>: Better formatting of progress bar in <code>vphi_from_fit</code></p> </li> <li> <p><code>a899159</code>: Minor improvements to the <code>vphi_from_fit</code> function</p> </li> </ul>"},{"location":"release-notes/#version-123","title":"Version 1.2.3","text":"<p>Released 14-04-2025 </p>"},{"location":"release-notes/#bug-fixes_14","title":"Bug Fixes","text":"<ul> <li><code>92a2ed0</code>: Bug in <code>ozzy.plot.hist</code> and <code>ozzy.plot.hist_proj</code> for weighted data</li> </ul>"},{"location":"release-notes/#version-122","title":"Version 1.2.2","text":"<p>Released 09-04-2025 </p>"},{"location":"release-notes/#bug-fixes_15","title":"Bug Fixes","text":"<ul> <li><code>1319ddf</code>: Typo was preventing <code>ozzy.statistics</code> from being imported</li> </ul>"},{"location":"release-notes/#version-121","title":"Version 1.2.1","text":"<p>Released 09-04-2025 </p>"},{"location":"release-notes/#bug-fixes_16","title":"Bug Fixes","text":"<ul> <li><code>57daddd</code>: Bug in <code>local_maxima_and_zero_crossings</code></li> </ul>"},{"location":"release-notes/#documentation_4","title":"Documentation","text":"<ul> <li><code>f4700b4</code>: Correct typos in docstring for <code>ozzy.fields.local_maxima_and_zero_crossings</code></li> </ul>"},{"location":"release-notes/#version-120","title":"Version 1.2.0","text":"<p>Released 03-04-2025 </p>"},{"location":"release-notes/#features_2","title":"Features","text":"<ul> <li><code>454aeee</code>: Add function to find local field maxima and zero crossings</li> </ul>"},{"location":"release-notes/#version-112","title":"Version 1.1.2","text":"<p>Released 17-02-2025 </p>"},{"location":"release-notes/#bug-fixes_17","title":"Bug Fixes","text":"<ul> <li><code>46d59fc</code>: Trigger new release to publish python-3.13-compatible update to pypi</li> </ul>"},{"location":"release-notes/#version-111","title":"Version 1.1.1","text":"<p>Released 17-02-2025 </p>"},{"location":"release-notes/#bug-fixes_18","title":"Bug Fixes","text":"<ul> <li><code>6066a3f</code>: Update package dependencies so that package works with python 3.13</li> </ul>"},{"location":"release-notes/#version-110","title":"Version 1.1.0","text":"<p>Released 17-02-2025 </p>"},{"location":"release-notes/#documentation_5","title":"Documentation","text":"<ul> <li><code>a156af7</code>: Instruct users to use the function <code>ozzy.utils.axis_from_extent</code> to create the axes dataset required for <code>bin_into_grid</code></li> </ul>"},{"location":"release-notes/#features_3","title":"Features","text":"<ul> <li> <p><code>7c39207</code>: Add functions to plot distributions of particle data</p> <p>Add <code>ozzy.plot.hist</code> and <code>ozzy.plot.hist_proj</code> to easily plot density distributions (histograms) of particle data, taking advantage of the seaborn functions <code>seaborn.histplot</code> and <code>seaborn.jointplot</code>.</p> <p>Previously it would have been necessary to bin the data first, and then plot, e.g.: </p><pre><code>import ozzy as oz\nimport ozzy.plot as oplt\n# A particle data Dataset\nds = oz.Dataset(..., pic_data_type=\"part\")\nds_ps = ds.ozzy.get_phase_space([\"p2\", \"x2\"])\nds_ps[\"rho\"].plot()\n</code></pre> While now the following code is enough: <pre><code>import ozzy as oz\nimport ozzy.plot as oplt\nds = oz.Dataset(..., pic_data_type='part')\noplt.hist(ds, x=\"x2\", y=\"p2\")\n</code></pre><p></p> </li> </ul>"},{"location":"release-notes/#refactoring_4","title":"Refactoring","text":"<ul> <li><code>703dfd3</code>: Change <code>ozzy.plot</code> defaults to display a plot grid</li> </ul>"},{"location":"release-notes/#version-109","title":"Version 1.0.9","text":"<p>Released 28-01-2025 </p>"},{"location":"release-notes/#bug-fixes_19","title":"Bug Fixes","text":"<ul> <li><code>a3cfe10</code>: One argument of <code>set_attr_if_exists</code> was missing its default value, which was throwing an error e.g. when <code>ds.ozzy.save</code> was called</li> </ul>"},{"location":"release-notes/#version-108","title":"Version 1.0.8","text":"<p>Released 24-01-2025 </p>"},{"location":"release-notes/#bug-fixes_20","title":"Bug Fixes","text":"<ul> <li><code>83329ef</code>: Fft method was throwing error due to data being a chunked dask array</li> </ul>"},{"location":"release-notes/#documentation_6","title":"Documentation","text":"<ul> <li><code>85a5f71</code>: Small formatting corrections</li> </ul>"},{"location":"release-notes/#version-107","title":"Version 1.0.7","text":"<p>Released 26-11-2024 </p>"},{"location":"release-notes/#bug-fixes_21","title":"Bug Fixes","text":"<ul> <li><code>48d0b14</code>: Fix bug that would throw error when using <code>open_compare</code> with multiple backends and with backend-specific keyword arguments</li> </ul>"},{"location":"release-notes/#documentation_7","title":"Documentation","text":"<ul> <li> <p><code>25b11d8</code>: Disable instant loading since this causes the feedback widget to only show after reloading the page</p> </li> <li> <p><code>e2c93ce</code>: Update installation instructions (now available on <code>conda-forge</code>) and update package dependencies (especially <code>makedocs-material</code>)</p> </li> </ul>"},{"location":"release-notes/#version-106","title":"Version 1.0.6","text":"<p>Released 13-11-2024 </p>"},{"location":"release-notes/#bug-fixes_22","title":"Bug Fixes","text":"<ul> <li><code>65c7549</code>: Expression with double quotes inside double quotes was throwing an error for python 3.10</li> </ul>"},{"location":"release-notes/#version-105","title":"Version 1.0.5","text":"<p>Released 13-11-2024 </p>"},{"location":"release-notes/#bug-fixes_23","title":"Bug Fixes","text":"<ul> <li><code>2c5fa8e</code>: Remove obsolete argument for <code>backend.parse_data</code> that was being called from <code>ozzy.open_compare</code> and raising an error</li> </ul>"},{"location":"release-notes/#documentation_8","title":"Documentation","text":"<ul> <li><code>60afa7d</code>: Fix some broken links after update</li> </ul>"},{"location":"release-notes/#version-104","title":"Version 1.0.4","text":"<p>Released 12-11-2024 </p>"},{"location":"release-notes/#bug-fixes_24","title":"Bug Fixes","text":"<ul> <li> <p><code>5cd488c</code>: Fix error thrown by <code>bin_into_grid</code> when called on a data object that didn't contain a <code>&amp;#39;t&amp;#39;</code> coordinate</p> </li> <li> <p><code>776a1a2</code>: Fix missing-argument error when trying to read <code>beamfile.bin</code> files</p> </li> </ul>"},{"location":"release-notes/#documentation_9","title":"Documentation","text":"<ul> <li> <p><code>b43f5dc</code>: Update documentation</p> </li> <li> <p><code>6c726a5</code>: Update \"installation\" and \"getting started\" page</p> </li> <li> <p><code>1bf9a95</code>: Change heading formatting of changelog template</p> </li> </ul>"},{"location":"release-notes/#refactoring_5","title":"Refactoring","text":"<ul> <li><code>825b7ab</code>: Change how backend-specific arguments are passed from the <code>open</code> functions to each backend (easier to extend)</li> </ul>"},{"location":"release-notes/#version-103","title":"Version 1.0.3","text":"<p>Released 04-11-2024 </p>"},{"location":"release-notes/#documentation_10","title":"Documentation","text":"<ul> <li><code>1c50582</code>: Correct changelog template</li> </ul>"},{"location":"release-notes/#version-102","title":"Version 1.0.2","text":"<p>Released 04-11-2024 </p>"},{"location":"release-notes/#documentation_11","title":"Documentation","text":"<ul> <li><code>2d1afe0</code>: Update installation instructions</li> </ul>"},{"location":"release-notes/#version-101","title":"Version 1.0.1","text":"<p>Released 04-11-2024 </p>"},{"location":"release-notes/#bug-fixes_25","title":"Bug Fixes","text":"<ul> <li> <p><code>0e0f1f2</code>: Fix attribute assignment in <code>bin_into_grid</code> and reorder dimensions after binning (for chunking and performance)</p> </li> <li> <p><code>9674d63</code>: Fix bug where <code>open_compare</code> was printing out \"reading files\" even when it had found no files</p> </li> </ul>"},{"location":"release-notes/#documentation_12","title":"Documentation","text":"<ul> <li> <p><code>28e05c2</code>: Change template for automatic changelog generation</p> </li> <li> <p><code>d91795b</code>: Add <code>plot_func</code> argument to <code>movie</code> docstring</p> </li> <li> <p><code>2a97bb6</code>: Add release notes to website, create custom changelog template</p> </li> </ul>"},{"location":"release-notes/#features_4","title":"Features","text":"<ul> <li> <p><code>10abc79</code>: Publish package on pypi with as <code>ozzy-pic</code></p> </li> <li> <p><code>0d2020a</code>: Add function to get beam emittance</p> </li> <li> <p><code>1ac93ae</code>: Add function to create an interactive animation using <code>hvplot</code></p> </li> <li> <p><code>3540a8e</code>: Make <code>movie</code> more customisable by having a function argument that can edit the plot at each frame</p> </li> <li> <p><code>dd58a21</code>: Add co-moving variables such as <code>x1_box</code> to particle data as well</p> </li> </ul>"},{"location":"release-notes/#performance-improvements","title":"Performance Improvements","text":"<ul> <li><code>e67f696</code>: Reorder and rechunk dimensions of data after binning in <code>bin_into_grid</code></li> </ul>"},{"location":"release-notes/#refactoring_6","title":"Refactoring","text":"<ul> <li> <p><code>0e98bbb</code>: Harmonize the metadata of lcode particle data (momentum) to standard names and units, update docs and tests</p> <p>The third momentum component in LCODE particle data corresponds to either \\(p_z\\) in Cartesian geometry or the angular momentum \\(L\\) in axisymmetric/cylindrical geometry. This is now taken into account via the boolean parameter <code>axisym</code> (<code>True</code> by default). In cylindrical geometry the third momentum component is renamed and a new <code>'p3'</code> variable is added to the dataset, corresponding to \\(p_\\theta = L / r\\).</p> <p>In addition, all momenta in LCODE particle data are normalised to \\(m_e \\ c\\). The units are now converted to \\(m_\\mathrm{sp} \\ c\\), using the charge-to-mass ratio in the data and the new argument <code>abs_q</code> (absolute value of the normalised bunch particle charge).</p> </li> <li> <p><code>d7da0c8</code>: Replace <code>statistics.parts_into_grid</code> with dataset method <code>bin_into_grid</code></p> <p>Replace <code>statistics.parts_into_grid</code> with a Dataset method called <code>bin_into_grid</code> accessible to particle data (<code>pic_data_type = 'part'</code>).</p> <p>Breaking change: <code>statistics.parts_into_grid</code> does not work anymore</p> <p>Please replace the function <code>statistics.parts_into_grid</code> with the <code>ds.ozzy.bin_into_grid</code> method. As an example, the following code</p> <p></p><pre><code>import ozzy as oz\nimport ozzy.statistics as stats\nimport numpy as np\n\nparticles = oz.Dataset(\n    {\n        \"x1\": (\"pid\", np.random.uniform(0, 10, 10000)),\n        \"x2\": (\"pid\", np.random.uniform(0, 5, 10000)),\n        \"q\": (\"pid\", np.ones(10000)),\n    },\n    coords={\"pid\": np.arange(10000)},\n    attrs={\"pic_data_type\": \"part\"}\n)\n\naxes = oz.Dataset(\n    coords={\n        \"x1\": np.linspace(0, 10, 101),\n        \"x2\": np.linspace(0, 5, 51),\n    },\n    attrs={\"pic_data_type\": \"grid\"}\n)\n\nbinned = stats.parts_into_grid(particles, axes, r_var=\"x2\")\ngrid_data_axisym = particles.ozzy.bin_into_grid(axes, r_var=\"x2\")\n</code></pre> should be replaced by<p></p> <pre><code>import ozzy as oz\nimport numpy as np\n...\nbinned = particles.ozzy.bin_into_grid(axes, r_var=\"x2\")\n</code></pre> </li> <li> <p><code>5840bc4</code>: Make str_exists argument of get_attr_if_exists optional</p> </li> <li> <p><code>5d53830</code>: Use helper functions to handle dataarray attributes whenever possible</p> </li> </ul>"},{"location":"release-notes/#version-021","title":"Version 0.2.1","text":"<p>Released 21-10-2024 </p>"},{"location":"release-notes/#bug-fixes_26","title":"Bug Fixes","text":"<ul> <li><code>0c2bb5f</code>: Error is now raised when an invalid n0 argument is passed to convert_q</li> </ul>"},{"location":"release-notes/#documentation_13","title":"Documentation","text":"<ul> <li> <p><code>426b187</code>: Add feedback widget across pages</p> </li> <li> <p><code>7877d0e</code>: Try to add umami analytics in different way</p> </li> <li> <p><code>3e62f7b</code>: Add umami analytics for documentation website</p> </li> <li> <p><code>ae7b7b3</code>: Add black as project dependency for better formatting of code signatures in documentation</p> </li> <li> <p><code>0bd401b</code>: Debug and small corrections</p> </li> <li> <p><code>29be6fd</code>: Change main blurb, include install instructions with git and poetry</p> </li> </ul>"},{"location":"release-notes/#refactoring_7","title":"Refactoring","text":"<ul> <li><code>a2d20bc</code>: Add two helper functions to set dataarray attributes depending on whether they already exist or not, + unit tests for these functions</li> </ul>"},{"location":"release-notes/#version-020","title":"Version 0.2.0","text":"<p>Released 15-10-2024 </p>"},{"location":"release-notes/#features_5","title":"Features","text":"<ul> <li><code>b4b61c7</code>: Save movies of ozzy plots</li> </ul>"},{"location":"release-notes/#version-017","title":"Version 0.1.7","text":"<p>Released 07-10-2024 </p>"},{"location":"release-notes/#bug-fixes_27","title":"Bug Fixes","text":"<ul> <li> <p><code>6fcd37d</code>: Get_phase_space bug fixes</p> <ul> <li>no error when limits are set automatically and all quantity values are zero</li> <li>make sure that axisymmetric geometry is taken into account correctly when the radius variable isn't being binned directly</li> </ul> </li> <li> <p><code>c12f766</code>: Correct units of particle momenta</p> </li> </ul>"},{"location":"release-notes/#version-016","title":"Version 0.1.6","text":"<p>Released 30-09-2024 </p>"},{"location":"release-notes/#bug-fixes_28","title":"Bug Fixes","text":"<ul> <li><code>96a7340</code>: Units in parts_into_grid are now fetched from raw_ds argument</li> </ul>"},{"location":"release-notes/#version-015","title":"Version 0.1.5","text":"<p>Released 23-09-2024 </p>"},{"location":"release-notes/#performance-improvements_1","title":"Performance Improvements","text":"<ul> <li><code>d4d08a5</code>: Improve concatenation of tb files along time</li> </ul>"},{"location":"release-notes/#refactoring_8","title":"Refactoring","text":"<ul> <li><code>1816b9b</code>: Add commented todo's</li> </ul>"},{"location":"release-notes/#version-014","title":"Version 0.1.4","text":"<p>Released 18-09-2024 </p>"},{"location":"release-notes/#bug-fixes_29","title":"Bug Fixes","text":"<ul> <li><code>6e84664</code>: Change momentum units</li> </ul>"},{"location":"release-notes/#features_6","title":"Features","text":"<ul> <li><code>de9520c</code>: Scaffolding for emittance method</li> </ul>"},{"location":"release-notes/#refactoring_9","title":"Refactoring","text":"<ul> <li> <p><code>506f060</code>: Replace ~ with not</p> </li> <li> <p><code>9ce2c8a</code>: Utils function to set attributes if they exist</p> </li> </ul>"},{"location":"release-notes/#version-013","title":"Version 0.1.3","text":"<p>Released 17-09-2024 </p>"},{"location":"release-notes/#bug-fixes_30","title":"Bug Fixes","text":"<ul> <li><code>022b0c4</code>: Change momentum units</li> </ul>"},{"location":"release-notes/#version-012","title":"Version 0.1.2","text":"<p>Released 17-09-2024 </p>"},{"location":"release-notes/#bug-fixes_31","title":"Bug Fixes","text":"<ul> <li><code>d48785c</code>: Change units of density in parts_into_grid</li> </ul>"},{"location":"release-notes/#refactoring_10","title":"Refactoring","text":"<ul> <li> <p><code>0bd8cc1</code>: Change norm. units of q in particle data</p> </li> <li> <p><code>1c5d48e</code>: Add axisym argument to get_phase_space</p> </li> </ul>"},{"location":"release-notes/#version-011","title":"Version 0.1.1","text":"<p>Released 13-08-2024 </p>"},{"location":"release-notes/#bug-fixes_32","title":"Bug Fixes","text":"<ul> <li><code>fed8f27</code>: Automatic extent calculation for phase space even when min = max</li> </ul>"},{"location":"release-notes/#documentation_14","title":"Documentation","text":"<ul> <li><code>1ef5d22</code>: Include zenodo reference</li> </ul>"},{"location":"release-notes/#refactoring_11","title":"Refactoring","text":"<ul> <li><code>2d79f50</code>: Utils function to set attributes if they exist</li> </ul>"},{"location":"release-notes/#version-010","title":"Version 0.1.0","text":"<p>Released 16-07-2024 </p>"},{"location":"release-notes/#features_7","title":"Features","text":"<ul> <li><code>109e196</code>: Set up cd of ozzy releases</li> </ul>"},{"location":"release-notes/#version-001","title":"Version 0.0.1","text":"<p>Released 16-07-2024 </p>"},{"location":"release-notes/#bug-fixes_33","title":"Bug Fixes","text":"<ul> <li><code>8e5fabd</code>: Use correct function to register colormap</li> </ul>"},{"location":"release-notes/#version-000","title":"Version 0.0.0","text":"<p>Released 16-07-2024 </p>"},{"location":"release-notes/#documentation_15","title":"Documentation","text":"<ul> <li> <p><code>62db369</code>: Write plotting section</p> </li> <li> <p><code>9fb57d8</code>: Write reading-files</p> </li> <li> <p><code>892ed52</code>: Add file save to quick example in getting started</p> </li> <li> <p><code>7c1fbd0</code>: Finish key concepts</p> </li> <li> <p><code>7272683</code>: Work on getting started</p> </li> <li> <p><code>079304f</code>: Work on getting started</p> </li> <li> <p><code>2d96a10</code>: Key concepts</p> </li> <li> <p><code>afd1953</code>: Write pages for each backend</p> </li> <li> <p><code>db3cd72</code>: Work on getting started</p> </li> <li> <p><code>c566890</code>: Formatting + start getting started</p> </li> <li> <p><code>1ce0289</code>: Activate section permalinks</p> </li> <li> <p><code>eb042d1</code>: Activate git date plugin</p> </li> <li> <p><code>1401ba4</code>: Small changes</p> </li> <li> <p><code>df428f2</code>: Solve bugs</p> </li> <li> <p><code>3481bfb</code>: Try to solve snippets issue</p> </li> <li> <p><code>4eb3b32</code>: Try to solve snippets issue</p> </li> <li> <p><code>8cab692</code>: Try to solve snippets issue</p> </li> <li> <p><code>0ecd710</code>: Finish license and about</p> </li> </ul>"},{"location":"user-guide/","title":"Welcome to the ozzy User Guide!","text":""},{"location":"user-guide/#welcome-to-the-ozzy-user-guide","title":"Welcome to the ozzy User Guide!","text":"<ul> <li> Installation</li> <li> Getting started</li> <li> Key concepts</li> <li> Reading files</li> <li> Plotting</li> </ul> <ul> <li> Analysis</li> <li> Notes on speed</li> </ul>"},{"location":"user-guide/analysis/","title":"Analysis","text":"<p>Page under development.</p>"},{"location":"user-guide/key-concepts/","title":"Key concepts","text":""},{"location":"user-guide/key-concepts/#key-concepts","title":"Key concepts","text":"<p>Here are the most important things to understand about ozzy and the upstream packages it uses.</p>"},{"location":"user-guide/key-concepts/#data-objects","title":"Data objects","text":"<p>Info</p> <p>This is a very brief introduction to the data objects used by ozzy.  Please refer to the \"Data structures\" section of xarray's User Guide for a complete tour.</p> <p>As mentioned before, xarray offers two types of object that can store information alongside a given dataset. You can imagine these data objects as a plot, in the sense that they contain all the information that a plot usually does: the data iself, axes, variable names and units, notes, etc.</p>"},{"location":"user-guide/key-concepts/#dataarray","title":"DataArray","text":"<p>A DataArray is the smallest unit of a data object in xarray. In the analogy of the data objects as plots, a DataArray would correspond to a single curve on a chart.</p> <p>A DataArray has the following properties:</p> DataArray <code>da</code> <code>da.values</code> the data, in the form of an <code>ndarray</code> <code>da.dims</code> the names of the data's dimensions (e.g. <code>'y'</code>, <code>'x'</code> instead of <code>0</code>, <code>1</code>) <code>da.coords</code> the axes for each dimension (there may be several for the same dimension), which are called Coordinates in xarray <code>da.attrs</code> any other user-defined metadata"},{"location":"user-guide/key-concepts/#dataset","title":"Dataset","text":"<p>A Dataset is a bundle of one or more DataArrays (in fact it can also be empty). In the analogy of the data plot, a Dataset can be any combination of plots and subplots; from a single curve to an ensemble of several charts with different axes and different data curves.</p> <p>This is particularly useful when we have several quantities (i.e., DataArrays, or variables) that are all defined on the same axes, for example the different components of the electric field. However, the different variables in a Dataset don't have to share axes and dimensions.</p> <p>A Dataset object contains:</p> Dataset <code>ds</code> <code>ds.data_vars</code> the quantities inside the Dataset, available as a dictionary mapping their names to the respective DataArrays <code>ds.dims</code> the names of the dimensions associated with the different quantity arrays <code>ds.coords</code> axes, i.e. xarray Coordinates <code>ds.attrs</code> any other user-defined metadata"},{"location":"user-guide/key-concepts/#specific-methods","title":"Specific methods","text":"<p>Besides some general methods that are available to all data objects(1), ozzy also makes different methods available depending on the type of data(2) and the simulation code that produced it(3). Access to these specific methods is granted based on two attributes: <code>pic_data_type</code> and <code>data_origin</code>. These attributes should be set when initializing a new data object with <code>ozzy.DataArray()</code> or <code>ozzy.Dataset()</code>. For example:</p> <ol> <li>See Code Reference \u2192 Data object methods \u2192 General methods.</li> <li>See Code Reference \u2192 Data object methods \u2192 Data-type-specific methods.</li> <li>See Code Reference \u2192 Data object methods \u2192 Backend-specific methods</li> </ol> <p>Initializing new data objects</p> DataArrayDataset <pre><code>import ozzy as oz\nda = oz.DataArray(pic_data_type='grid', data_origin='ozzy')\nprint(da)\n# &lt;xarray.DataArray ()&gt;\n# array(nan)\n# Attributes:\n#     pic_data_type:  grid\n#     data_origin:    ozzy\n</code></pre> <pre><code>import ozzy as oz\nds = oz.Dataset(pic_data_type='grid', data_origin='ozzy')\nprint(ds)\n# &lt;xarray.Dataset&gt;\n# Dimensions:  ()\n# Data variables:\n#     *empty*\n# Attributes:\n#     pic_data_type:  grid\n#     data_origin:    ozzy\n</code></pre> <p>The following values are accepted for these two attributes:</p> Attribute Accepted values Default <code>'pic_data_type'</code> <code>'grid'</code>, <code>'part'</code> <code>None</code> <code>'data_origin'</code> <code>'ozzy'</code>, <code>'osiris'</code>, <code>'lcode'</code> <code>None</code>"},{"location":"user-guide/key-concepts/#table-of-data-objects","title":"Table of data objects","text":"<p>The <code>open_compare</code> function allows the user to open several sets of data from different simulation folders and/or simulation codes, and returns them organized into a table where each row corresponds to a simulation folder and each column to a quantity. The returned object is in fact a <code>pandas.DataFrame</code>, which is a powerful implementation of a table with column and row labels and fast look-up methods (see Pandas for more information).</p>"},{"location":"user-guide/key-concepts/#indexing","title":"Indexing","text":"<p>Info</p> <p>Please see the section on \"Indexing and selecting data\" in xarray's User Guide for a complete explanation of available indexing methods.</p> <p>Besides standard array indexing (such as <code>a[i,j]</code>), the main ways to select slices of data in DataArrays or Datasets are <code>.sel()</code> and <code>.isel()</code>. A simple example is shown below.</p> Example of indexing methods DataArrayDataset <pre><code>import numpy as np\nimport ozzy as oz\n\n# Create a 2D DataArray\nx = np.linspace(-5, 5, 50)\ny = np.linspace(-3, 3, 30)\nX, Y = np.meshgrid(x, y)\nne = np.exp(-(X**2 + Y**2) / 2)\n\nda = oz.DataArray(\n    data=ne,\n    dims=[\"y\", \"x\"],\n    coords={\"x\": x, \"y\": y},\n    name=\"ne\",\n    pic_data_type=\"grid\",\n    data_origin=\"ozzy\",\n)\n\n# Select line-out at center of x axis\n# The following are all equivalent\nda[:, 24]\nda.isel(x=24) #(1)!\nda.sel(x=0.0, method=\"nearest\") #(2)!\n\nprint(da.sel(x=0.0, method=\"nearest\"))\n# &lt;xarray.DataArray 'ne' (y: 30)&gt;\n# array([...])\n# Coordinates:\n#     x        float64 0.102\n#   * y        (y) float64 -3.0 -2.793 -2.586 -2.379 ... 2.379 2.586 2.793 3.0\n# Attributes:\n#     pic_data_type:  grid\n#     data_origin:    ozzy\n</code></pre> <ol> <li>See <code>xarray.DataArray.isel</code>.</li> <li>See <code>xarray.DataArray.sel</code>.</li> </ol> <pre><code>import ozzy as oz\nimport numpy as np\n\n# Create coordinates\nx = np.linspace(-5, 5, 50)\ny = np.linspace(-3, 3, 30)\nX, Y = np.meshgrid(x, y)\n\n# Create data variables\nne = np.exp(-(X**2 + Y**2) / 2)\nEx = np.sin(x) * np.exp(-x**2 / 10)\n\nds = oz.Dataset(\n    data_vars={\n        'ne': (['y', 'x'], ne),\n        'Ex': (['x'], Ex)\n    },\n    coords={'x': x, 'y': y},\n    attrs={\n        'pic_data_type': 'grid',\n        'data_origin': 'ozzy'\n    }\n)\n\n# Select data at center of x axis\n# The following are equivalent\n# Note that positional indexing does not work on Datasets\nds.isel(x=24) #(1)!\nds.sel(x=0.0, method=\"nearest\") #(2)!\n\nprint(ds.sel(x=0.0, method=\"nearest\")) #(3)!\n# &lt;xarray.Dataset&gt;\n# Dimensions:  (y: 30)\n# Coordinates:\n#     x        float64 0.102\n#   * y        (y) float64 -3.0 -2.793 -2.586 -2.379 ... 2.379 2.586 2.793 3.0\n# Data variables:\n#     ne       (y) float64 0.01105 0.02012 0.0351 ... 0.0351 0.02012 0.01105\n#     Ex       float64 0.1018\n# Attributes:\n#     pic_data_type:  grid\n#     data_origin:    ozzy\n</code></pre> <ol> <li>See <code>xarray.Dataset.isel</code>.</li> <li>See <code>xarray.Dataset.sel</code>.</li> <li>Notice how each data variable inside the Dataset was sliced.</li> </ol> <p>When data objects are organized in a table (<code>pandas.DataFrame</code>), items can be accessed either via the row and column labels or with a numerical index, with <code>.loc</code> or <code>.at</code> and <code>.iloc</code> or <code>.iat</code>, respectively.</p> Indexing elements in a DataFrame (table) <p></p><pre><code>import ozzy as oz\nimport pandas as pd\n\n# Create empty Datasets to serve as placeholders\nds_sim1_ne = oz.Dataset()\nds_sim1_Ez = oz.Dataset()\nds_sim2_ne = oz.Dataset()\nds_sim2_Ez = oz.Dataset()\n\n# Create a DataFrame with Dataset objects, \n# similar to the output of ozzy.open_compare()\ndf = pd.DataFrame(\n    [[ds_sim1_ne, ds_sim2_ne], [ds_sim1_Ez, ds_sim2_Ez]],\n    index=[\"Simulation 1\", \"Simulation 2\"],\n    columns=[\"ne\", \"Ez\"],\n)\nprint(df)\n#               ne  Ez\n# Simulation 1  []  []\n# Simulation 2  []  []\n</code></pre> We obtain one of the empty datasets when we select a single table cell:<p></p> <pre><code># The following are equivalent\ndf.loc[\"Simulation 1\", \"Ez\"]\ndf.iloc[0, 1]\ndf.at[\"Simulation 1\", \"Ez\"]\ndf.iat[0, 1]\n\nprint(df.iloc[0, 1])\n# &lt;xarray.Dataset&gt;\n# Dimensions:  ()\n# Data variables:\n#     *empty*\n# Attributes:\n#     pic_data_type:  None\n#     data_origin:    None\n</code></pre> <p>Slicing a row or column returns a <code>pandas.Series</code> object.</p> <pre><code># Selecting the second row\ndf.loc[\"Simulation 2\"]\n# Selecting the first column\ndf.iloc[:, 0]\n\nprint(df.loc[\"Simulation 2\"])\n# ne    []\n# Ez    []\n# Name: Simulation 2, dtype: object\n</code></pre>"},{"location":"user-guide/key-concepts/#data-chunking-and-lazy-loading","title":"Data chunking and lazy loading","text":"<p>A common issue with simulation files is their sheer size, which often implies long loading, processing and plotting times. One strategy to deal with extremely large files is to load them into the machine's working memory in smaller \"chunks\", which is called data chunking. Another strategy is called lazy loading, where data is not actually processed until absolutely necessary. Both of these techniques are used in ozzy thanks to the Dask package, which is also integrated into xarray.</p> <p>Files read by ozzy will generally be Dask arrays under the hood. This does not change much in the way you interact with the data object, with the exception that operations on it will not actually be computed until you explicitly say so, with the <code>.compute</code>(1) or <code>.load</code>(2) methods. Below is an example demonstrating how this works.</p> <ol> <li>See <code>xarray.DataArray.compute</code> or <code>xarray.Dataset.compute</code>.</li> <li>See <code>xarray.DataArray.load</code> or <code>xarray.Dataset.load</code>.</li> </ol> <p>Info</p> <p>Please see \"Using Dask with xarray\" from the xarray User Guide for more detail.</p> Understanding lazy loading <p></p><pre><code>import dask.array as da\nimport numpy as np\nimport ozzy as oz\n\n# Create a large dataset that would typically be too big to fit in memory\nlarge_data = np.random.rand(1000000, 1000)  # 1 million x 1000 array\n\n# Initialize a Dataset with chunking\ndask_data = da.from_array(large_data, chunks=(100000, 100))\nds = oz.Dataset(\n    {\"large_variable\": ([\"x\", \"y\"], dask_data)},\n)\nprint(\"-&gt; Dataset created, but data not loaded into memory yet.\")\nprint(ds)\n\n# Perform a computation that doesn't require loading all the data\nresult = ds.large_variable.mean(dim=\"y\")\nprint(\"\\n-&gt; Computation defined, but not yet executed:\")\nprint(result)\n\n# Trigger actual computation\nprint(\"\\n-&gt; Triggering computation:\")\nresult = result.compute()\nprint(result)\n</code></pre> This produces the following output: <pre><code>-&gt; Dataset created, but data not loaded into memory yet.\n&lt;xarray.Dataset&gt;\nDimensions:         (x: 1000000, y: 1000)\nDimensions without coordinates: x, y\nData variables:\n    large_variable  (x, y) float64 dask.array&lt;chunksize=(100000, 100), meta=np.ndarray&gt;\nAttributes:\n    pic_data_type:  None\n    data_origin:    None\n\n-&gt; Computation defined, but not yet executed:\n&lt;xarray.DataArray 'large_variable' (x: 1000000)&gt;\ndask.array&lt;mean_agg-aggregate, shape=(1000000,), dtype=float64, chunksize=(100000,), chunktype=numpy.ndarray&gt;\nDimensions without coordinates: x\n\n-&gt; Triggering computation:\n&lt;xarray.DataArray 'large_variable' (x: 1000000)&gt;\narray([0.50542762, 0.50724898, 0.48675328, ..., 0.50791182, 0.5187294 ,\n    0.49262436])\nDimensions without coordinates: x\n</code></pre><p></p>"},{"location":"user-guide/plotting/","title":"Plotting","text":""},{"location":"user-guide/plotting/#plotting","title":"Plotting","text":"<p>It is extremely easy to plot xarray data objects, for example simply by calling <code>xarray.DataArray.plot()</code>. Xarray wraps the matplotlib library and makes its functions available as <code>DataArray</code> and <code>Dataset</code> methods.</p> <p>Info</p> <p>Please consult the \"Plotting\" section of xarray's User Guide to learn about all of its plotting capabilities.</p> Interactive plots <p>It is also very easy to produce interactive plots of xarray data objects with hvPlot.</p> <p>Though xarray's plotting capabilities can be used directly, ozzy does some extra aesthetic tinkering when the plotting submodule, <code>ozzy.plot</code>, is loaded. This submodule activates the following defaults:</p> Defaults Curve color scheme <code>'tol.muted'</code> Sequential colormap <code>'cmc.lipari'</code> Diverging colormap <code>'cmc.vik'</code> Font Noto Serif"},{"location":"user-guide/plotting/#color-maps-and-schemes","title":"Color maps and schemes","text":"<p>Ozzy aims to make scientific plots as accessible and as scientific as possible. In accordance with this principle, the default color maps and color schemes in <code>ozzy.plot</code> are perceptually uniform and readable by people with color-blindness. However, several color options that fulfill these criteria are available, most of which were developed by Fabio Crameri and Paul Tol.</p> <p>Acknowledging Fabio Crameri's \"Scientific colour maps\"</p> <p>Please note that color maps developed by Fabio Crameri, which includes the default color maps <code>vik</code> (diverging) and <code>lipari</code> (sequential), should be acknowledged if used in a published image, for example with:</p> <p>The Scientific colour map lipari<sup>1</sup> is used in this study to prevent visual distortion of the data and exclusion of readers with colour-vision deficiencies<sup>2</sup>.</p> <p>A sample of all available color maps and color schemes in <code>ozzy.plot</code> can be produced with:</p> <pre><code>import ozzy.plot as oplt\noplt.show_cmaps()\n</code></pre>"},{"location":"user-guide/plotting/#fonts","title":"Fonts","text":"<p>Ozzy's plotting submodule also bundles a few different open-source fonts:</p> <ul> <li>Crimson Pro</li> <li>Maitree</li> <li>Noto Serif</li> <li>Roboto Serif </li> <li>Source Serif 4 </li> <li>STIX Two Text</li> </ul> <p>Alternatively, LaTeX font can be used for all text and labels with:</p> <pre><code>import ozzy.plot as oplt\nimport matplotlib.pyplot as plt\nplt.rcParams[\"text.usetex\"] = True\n</code></pre> <p>To see all available fonts on the system, use:</p> <pre><code>import ozzy.plot as oplt\noplt.show_fonts(samples=True)\n</code></pre>"},{"location":"user-guide/plotting/#see-also","title":"See also","text":"<ul> <li>The seaborn library (used by ozzy to set the figure context)</li> <li>matplotlib</li> </ul> <ol> <li> <p>F. Crameri, \"Scientific colour maps\". Zenodo, Oct. 05, 2023. doi: 10.5281/zenodo.8409685.\u00a0\u21a9</p> </li> <li> <p>F. Crameri, G.E. Shephard, and P.J. Heron, \"The misuse of colour in science communication\". Nat. Commun. 11, 5444 (2020). doi: 10.1038/s41467-020-19160-7.\u00a0\u21a9</p> </li> </ol>"},{"location":"user-guide/reading-files/","title":"Reading files","text":""},{"location":"user-guide/reading-files/#reading-files","title":"Reading files","text":"<p>One of the main motivations behind ozzy is to be able to easily integrate different simulation file formats into the same plotting and analysis workflow (in this case with Python). In addition, we try to make it easy to add new backend instructions to ozzy to parse new file formats.</p> <p>Here is a list of simulation file formats that ozzy can read currently or which will be implemented soon (besides ozzy's own format, of course):</p> <ul> <li> OSIRIS (1)</li> <li> LCODE (2)</li> <li> openPMD</li> </ul> <ol> <li>Please see the reference page for the OSIRIS backend submodule for more details. Not all types of simulation output may be available yet.</li> <li>Please see the reference page for the LCODE backend submodule. Not all types of simulation output may be available yet.</li> </ol> <p>There are three main functions to open simulation files:</p> <ul> <li> <p><code>open</code> - for a single file</p> </li> <li> <p><code>open_series</code> - for a time series of files, where each file corresponds to a different time</p> </li> <li><code>open_compare</code> - for any combination of quantities and folder structures; particularly useful for comparisons across different runs, either stemming from a single simulation code or several</li> </ul> <p>In general, these functions expect the file format(s) as their first argument.</p>"},{"location":"user-guide/reading-files/#reading-a-single-file","title":"Reading a single file","text":"<p>In order to open a single file, the path to the file must be specified. This path can be relative, absolute, and it can include <code>~</code> as a shortcut to the user's home directory as well as glob patterns(1).</p> <ol> <li>Note that ozzy will only open the first file in case it finds several files matching the pattern.</li> </ol> <p>Opening a single file</p> OSIRISLCODEozzy <pre><code>import ozzy as oz\nds = oz.open('osiris', '~/path/to/file/e1-000020.h5')\n</code></pre> <p>LCODE simulation files do not contain any axis information, so we can supply the simulation window size in order to define the axis coordinates (optional).</p> <pre><code>import ozzy as oz\nds = oz.open(\n    'lcode', 'path/to/file/ez02500.swp', \n    axes_lims = {'x1': (-100,0.0), 'x2': (0.0, 6.0)}\n)\n</code></pre> <pre><code>import ozzy as oz\nds = oz.open('ozzy', '/Users/Ada/Desktop/Ex_max_mean.h5')\n</code></pre>"},{"location":"user-guide/reading-files/#reading-a-series-of-files","title":"Reading a series of files","text":"<p>The output from PIC simulations is often dumped into files at certain timesteps, and therefore often organized according to simulation time. Ozzy can easily treat all the files related to a given quantity as a single dataset with an additional time axis.</p> <p>Opening files as a time series</p> OSIRISLCODEozzy <p>For this example, let's say we have the following typical OSIRIS output folder structure:</p> <p></p><pre><code>.\n\u2514\u2500\u2500 my_sim/\n    \u2514\u2500\u2500 MS/\n        \u251c\u2500\u2500 FLD/\n        \u2502   \u2514\u2500\u2500 e1/\n        \u2502       \u251c\u2500\u2500 e1-000000.h5\n        \u2502       \u251c\u2500\u2500 e1-000001.h5\n        \u2502       \u251c\u2500\u2500 e1-000002.h5\n        \u2502       \u251c\u2500\u2500 ...\n        \u2502       \u2514\u2500\u2500 e1-000050.h5\n        \u251c\u2500\u2500 DENSITY\n        \u2514\u2500\u2500 RAW\n</code></pre> To open the \\(E_z\\) field data (called <code>e1</code> in OSIRIS) as a time series, we could use:<p></p> <pre><code>import ozzy as oz\nds = oz.open_series(\n    'osiris', \n    'my_sim/**/e1-*.h5', \n    nfiles=10,#(1)!\n)\n</code></pre> <ol> <li>We use the optional <code>nfiles</code> argument to open only the first 10 files.</li> </ol> <p>Let's say we have the following folder containing LCODE \\(E_z\\) field data both as 2D maps and on-axis line-outs:</p> <pre><code>.\n\u2514\u2500\u2500 my_lcode_sim/\n    \u251c\u2500\u2500 ez00200.swp\n    \u251c\u2500\u2500 ez00400.swp\n    \u251c\u2500\u2500 ez00600.swp\n    \u251c\u2500\u2500 ...\n    \u251c\u2500\u2500 ez02000.swp\n    \u251c\u2500\u2500 xi_00200.swp\n    \u251c\u2500\u2500 xi_00400.swp\n    \u251c\u2500\u2500 xi_00600.swp\n    \u251c\u2500\u2500 ...\n    \u251c\u2500\u2500 xi_02000.swp\n    \u251c\u2500\u2500 xi_Ez_00200.swp\n    \u251c\u2500\u2500 xi_Ez_00400.swp\n    \u251c\u2500\u2500 xi_Ez_00600.swp\n    \u251c\u2500\u2500 ...\n    \u2514\u2500\u2500 xi_Ez_02000.swp\n</code></pre> <p>We can read the 2D field maps with:</p> <pre><code>import ozzy as oz\nds = oz.open_series(\n    'lcode', \n    'my_lcode_sim/ez*.swp', \n    axes_lims={'x1': (-100,0.0), 'x2': (0.0, 6.0)}, #(1)!\n)\n</code></pre> <ol> <li>Appending information about the simulation window so that the Dataset contains axis information (Coordinates).</li> </ol> <p>We could also read the lineouts of \\(E_z\\) with:</p> <p></p><pre><code>import ozzy as oz\nds = oz.open_series('lcode', 'my_lcode_sim/xi_Ez_*.swp')\n</code></pre> Note that we do not need to specify the axis limits with the keyword argument <code>axes_lims</code> since ozzy automatically tries to obtain the \\(\\xi\\) axis information from the <code>xi_?????.swp</code> files.<p></p> <p>Given the following directory, which contains a time series of ozzy data in HDF5 format:</p> <p></p><pre><code>/usr/\n\u2514\u2500\u2500 ada/\n    \u2514\u2500\u2500 analysis/\n        \u2514\u2500\u2500 my_data/\n            \u251c\u2500\u2500 Ez_0001.h5\n            \u251c\u2500\u2500 Ez_0002.h5\n            \u251c\u2500\u2500 Ez_0003.h5\n            \u251c\u2500\u2500 ...\n            \u2514\u2500\u2500 Ez_0050.h5\n</code></pre> We can open the first three files with:<p></p> <pre><code>import ozzy as oz\nds = oz.open_series('ozzy', '~/my_data/Ez_*.h5', nfiles=3)\n</code></pre>"},{"location":"user-guide/reading-files/#reading-many-different-types-of-files","title":"Reading many different types of files","text":"<p>We often want to compare the output of several different simulations, or \"runs\", for the same quantity. The  <code>open_compare</code> function tries to make this comparison as easy as possible, organizing the imported data in a table(1) with labels for each different case and quantity.</p> <ol> <li>For more information about the format of this table, see Table of data objects in Key concepts.</li> </ol> <p>Opening multiple files for comparison</p> <p>Let's say we want to compare field data from multiple runs which are organized in the following folder structure:</p> <p></p><pre><code>.\n\u2514\u2500\u2500 MySimulations/\n    \u251c\u2500\u2500 OSIRIS/\n    \u2502   \u251c\u2500\u2500 run_1/\n    \u2502   \u2502   \u2514\u2500\u2500 e1-000020.h5\n    \u2502   \u2514\u2500\u2500 run_2/\n    \u2502       \u2514\u2500\u2500 e1-000020.h5\n    \u2514\u2500\u2500 LCODE/\n        \u251c\u2500\u2500 run_1/\n        \u2502   \u2514\u2500\u2500 ez02500.swp\n        \u2514\u2500\u2500 run_2/\n            \u2514\u2500\u2500 ez05000.swp\n</code></pre> We can use the following arguments to exclude the folder <code>LCODE/run_2</code> (since it corresponds to the wrong time in our example) and read the rest of the files:<p></p> <p></p><pre><code>import ozzy as oz\n\ndf = oz.open_compare(\n    file_types=['osiris', 'lcode'],\n    path='/MySimulations',\n    runs=['**/run_1', 'OSIRIS/run_2'],\n    quants=['e1', 'ez'],\n    axes_lims={'x1': (-100, 0), 'x2': (0, 6)},\n)\nprint(df)\n#                 e1    ez\n# OSIRIS/run_1  [ds]   []\n# OSIRIS/run_2  [ds]   []\n# LCODE/run_1    []   [ds]\n</code></pre> Individual datasets can be accessed for example with:<p></p> <pre><code>osiris_run1_e1 = df.at['OSIRIS/run_1', 'e1']\nlcode_run1_ez = df.at['LCODE/run_1', 'ez']\n</code></pre>"},{"location":"user-guide/reading-files/#manipulating-the-comparison-table","title":"Manipulating the comparison table","text":"<p>Below are a couple of examples demonstrating how the DataFrame returned by <code>open_compare</code> can be manipulated with the help of methods like <code>pandas.DataFrame.map</code> and <code>pandas.DataFrame.iterrows</code>.</p> <p>Convert all datasets to physical units</p> <pre><code>import ozzy as oz\n\ndf = oz.open_compare(\n    file_types='osiris',\n    path='/path/to/simulations',\n    runs=['run_1', 'run_2', 'run_3'],\n    quants='charge-electrons'\n)\n\n# Define a function to convert coordinates to physical units\ndef convert_to_physical(ds, n0):\n    if 'z' not in ds.coords:\n        ds = ds.ozzy.coord_to_physical_distance('t', n0, new_coord='z')#(1)!\n    return ds\n\n# Define plasma densities for each run\nn0_values = {'run_1': 7e14, 'run_2': 1e18, 'run_3': 3e18}  \n\ndf = df.map(lambda run: convert_to_physical(df.at[run, 'charge-electrons'], n0_values[run]))#(2)!\n</code></pre> <ol> <li>See <code>xarray.Dataset.ozzy.coord_to_physical_distance</code>.</li> <li>See <code>pandas.DataFrame.map</code>.</li> </ol> <p>Iterate along rows</p> <pre><code>import ozzy as oz\n\ndf = oz.open_compare(\n    'lcode'\n    path='/path/to/simulations',\n    runs='run_baseline',\n    quants=['er','bf'],\n)\n\nfor run, row in df.iterrows():#(1)!\n    print(f\"Processing run: {run}\")\n    ds_er = row['er']\n    ds_bf = row['bf']\n</code></pre> <ol> <li>See <code>pandas.DataFrame.iterrows</code>.</li> </ol>"},{"location":"user-guide/speed/","title":"Notes on speed","text":"<p>Page under development.</p>"},{"location":"user-guide/getting-started/","title":"Getting started","text":""},{"location":"user-guide/getting-started/#getting-started","title":"Getting started","text":"<p>Ozzy's main strength is that it is built on the xarray package. The logic behind xarray (and therefore ozzy) consists of handling numerical data as a \"package\" that includes the axis information and other metadata besides the actual data itself (similarly to the HDF5 file format, for example). This package can take the form of either a DataArray or a Dataset (see Data objects in Key concepts for more details).</p> <p>Once a file has been read by ozzy and translated into a data object (either a DataArray or a Dataset), we can take advantage of xarray's vast repertoire of built-in methods and functions. This generally includes all the operations that you would otherwise perform on a NumPy array (an <code>ndarray</code>), as well as xarray's plotting shortcuts.</p> <p>Quick example</p> <p>Let's construct some sample data of an oscillating electric field whose amplitude decreases along time. </p> <pre><code>import matplotlib.pyplot as plt\nimport numpy as np\nimport ozzy as oz\nimport ozzy.plot #(5)!\n\n# ------------------ Create sample data ------------------ \nt = np.linspace(0, 100, 300) #(4)!\nx = np.linspace(-10, 0, 200)\nEx = np.outer(np.exp(-0.001 * t**2), np.sin(x))\n\n# Create a data object (in this case a DataArray)\nda = oz.DataArray(\n    Ex,\n    dims=[\"t\", \"x\"],\n    coords={\"t\": t, \"x\": x},\n    name=\"Ex\",\n    attrs={\"long_name\": r\"$E_x$\", \"units\": r\"$E_0$\"},  #(1)!\n)\nda[\"t\"] = da[\"t\"].assign_attrs(long_name=r\"$t$\", units=r\"$\\omega_p^{-1}$\")\nda[\"x\"] = da[\"x\"].assign_attrs(long_name=r\"$x$\", units=r\"$c / \\omega_p$\")\n# --------------------------------------------------------\n\n# Take maximum and median of data\nda_max = da.max(dim=\"x\")  #(2)!\nda_mean = da.mean(dim=\"x\")  #(3)!\n\n# Plot - initial data\nplt.subplots()\nda.plot()\nplt.show()\n\n# Plot - max and mean\nplt.subplots()\nda_max.plot(label=\"max\")\nda_mean.plot(label=\"mean\")\nplt.grid()\nplt.legend()\nplt.show()\n\n# Save second plot\nplt.savefig(\"Ex_max_mean.png\")\n\n# Save result as a Dataset\nds_out = oz.Dataset(\n    {\"Ex_max\": da_max, \"Ex_mean\": da_mean},\n    pic_data_type=\"grid\", \n    data_origin=\"ozzy\"\n)\nds_out.ozzy.save(\"Ex_max_mean.h5\")\n</code></pre> <p>We've taken the maximum and mean values along the spatial dimension \\(x\\) for each time \\(t\\), and plotted the result. The generated plots look like this:</p> <p></p> Initial field data <p></p> <p></p> Maximum and mean along \\(t\\) <p></p> <ol> <li>The <code>'long_name'</code> and <code>'units'</code> attributes are automatically used by xarray to label plots.</li> <li>See xarray.DataArray.max. Note that the result is again a DataArray.</li> <li>See xarray.DataArray.mean. Note that the result is again a DataArray.</li> <li>This is where you would usually load simulation files, for example with:     <pre><code>ds = oz.open_series(\"osiris\", \"/path/to/simulation/file/e1-*.h5\")\nda = ds['e1']\n</code></pre></li> <li>Loading <code>ozzy.plot</code> ensures that the ozzy's styling is applied to all plots.</li> </ol> <p>Explore the examples below to better understand how ozzy works:</p> <p> Subtract two field components</p> <p> Phase space and histograms from particle data</p> <p> Charge density from particle data</p>"},{"location":"user-guide/getting-started/charge-density/","title":"Charge density from particle data","text":"<p>Page under development.</p>"},{"location":"user-guide/getting-started/phase-space/","title":"Phase space and histograms from particle data","text":"<p>Page under development.</p>"},{"location":"user-guide/getting-started/subtract-two-field-components/","title":"Subtract two field components","text":""},{"location":"user-guide/getting-started/subtract-two-field-components/#subtract-two-field-components","title":"Subtract two field components","text":"<p>Let's assume we have the data for two components of the electromagnetic fields, \\(E_r\\) and \\(B_\\theta\\), in a 2D cylindrical simulation.</p> OSIRISLCODEDummy data <pre><code>import ozzy as oz\ne2_ds = oz.open('osiris', 'path/to/file/MS/FLD/e2/e2-000010.h5')\nb3_ds = oz.open('osiris', 'path/to/file/MS/FLD/b3/b3-000010.h5')\nprint(e2_ds)\n</code></pre> <pre><code>import ozzy as oz\ne2_ds = oz.open('lcode', 'path/to/file/er00200.swp')\nb3_ds = oz.open('lcode', 'path/to/file/bf00200.swp')\nprint(e2_ds)\n</code></pre> <pre><code>import ozzy as oz\nimport numpy as np\n\n# Create some dummy data\nx1 = np.linspace(0, 10, 100)\nx2 = np.linspace(-5, 5, 50)\ne2_data = np.random.rand(50, 100)\nb3_data = np.random.rand(50, 100)\n\n# Create the Datasets\ne2_ds = oz.Dataset({'e2': (['x2','x1'],e2_data)}, coords={'x1': x1, 'x2': x2}, pic_data_type='grid', data_origin='ozzy')\nb3_ds = oz.Dataset({'b3': (['x2','x1'],b3_data)}, coords={'x1': x1, 'x2': x2}, pic_data_type='grid', data_origin='ozzy')\n\nprint(e2_ds)\n</code></pre> <p>Right now we have two datasets (one for each field component). Since these data variables share the same axes (\"coordinates\" in xarray nomenclature), we can easily merge both datasets.</p> <pre><code>import xarray as xr\nfields = xr.merge([e2_ds,b3_ds])\nprint(fields)\n</code></pre> <p>In this example we want to obtain the radial force associated with the electromagnetic fields of an axisymmetric plasma wave. In the normalized units used in most PIC codes, the radial force (on a positive particle) is defined simply as \\(W_r = E_r - B_\\theta\\). We can perform the subtraction and store the result as a new variable in the same dataset.</p> <pre><code>fields['wr'] = fields['e2'] - fields['b3']\nprint(fields['wr'])\n</code></pre> <p>Afterwards, we can save the result as an HDF5 file.</p> <pre><code># We're leaving e2 and b3 aside\nfields['wr'].ozzy.save('wr.h5')\n</code></pre>"},{"location":"user-guide/installation/","title":"Installation","text":""},{"location":"user-guide/installation/#installation","title":"Installation","text":"<p>Ozzy is a Python package. We recommend installing ozzy in its own virtual environment, since it depends on several other packages. If you're not familiar with Python or virtual environments, see our guide to setting up a virtual environment.</p>"},{"location":"user-guide/installation/#requirements","title":"Requirements","text":"<ul> <li>Python &gt;= 3.10</li> </ul>"},{"location":"user-guide/installation/#with-conda-recommended","title":"with conda (recommended)","text":"<p>Note about mamba</p> <p>Feel free to replace the <code>conda</code> command with <code>mamba</code>. Mamba is a faster version of the conda package manager, and is installed by default with miniforge.</p> <p>After you have activated a new virtual environment, run:</p> <pre><code>conda install --channel=conda-forge ozzy-pic\n</code></pre>"},{"location":"user-guide/installation/#with-pip","title":"with pip","text":"<p>After you have activated a new virtual environment, run:</p> <pre><code>python3 -m pip install ozzy-pic\n</code></pre>"},{"location":"user-guide/installation/#with-git-poetry","title":"with git + Poetry","text":"<p>This installation method can be used as a fallback, or in case the user wants to have access to the latest commit.</p>"},{"location":"user-guide/installation/#step-1-requirements","title":"Step 1 - Requirements","text":"<p>Make sure that git is installed on your system and that you have a virtual environment manager for your Python projects. In these instructions we will use <code>mamba</code> as the environment manager.</p>"},{"location":"user-guide/installation/#step-2-clone-the-ozzy-repository","title":"Step 2 - Clone the ozzy repository","text":"<p>Navigate to a directory of your choosing where you feel comfortable installing additional software, and clone the ozzy repository from GitHub: </p><pre><code># for example:\ncd ~/opt\n</code></pre> <pre><code>git clone https://github.com/mtrocadomoreira/ozzy.git\n</code></pre><p></p>"},{"location":"user-guide/installation/#step-3-create-a-new-environment","title":"Step 3 - Create a new environment","text":"<p>Here we use <code>mamba</code> to create a virtual environment called <code>ozzy-git</code> and then activate it: </p><pre><code>mamba create -n ozzy-git\n</code></pre> <pre><code>mamba activate ozzy-git\n</code></pre><p></p>"},{"location":"user-guide/installation/#step-4-install-ozzy-with-poetry","title":"Step 4 - Install ozzy with Poetry","text":"<p>We will use Poetry to install ozzy and its dependencies. Making sure that the virtual environment you created in Step 3 is activated, install Poetry: </p><pre><code>mamba install poetry\n</code></pre> Enter the directory where ozzy was cloned to (e.g. <code>cd ozzy</code>). It should contain a <code>README.md</code> file and some folders called <code>src</code>, <code>docs</code>, <code>tests</code>, etc. In this directory, run: <pre><code>poetry install\n</code></pre><p></p> <p>After this step, ozzy should be installed successfully. You can check this by opening a Python shell in your terminal and importing ozzy.</p> <pre><code>python3\n&gt;&gt;&gt; import ozzy\n</code></pre> <p>If there is no error message, ozzy is installed correctly.</p> <p>Note</p> <p>Please remember that the virtual environment you created must be activated whenever you want to use ozzy. </p> <p>If you use Jupyter Notebooks or other interactive text editors such as Visual Studio Code, you have to instruct the application to use the kernel from your virtual environment. Virtual environments are often found and managed automatically by this kind of applications, but some setting up may be required.</p> <p>Updating ozzy</p> <p>Whenever you want to update your ozzy installation to the latest version, run the following commands from inside the ozzy source code folder (e.g. <code>~/opt/ozzy</code>) and after activating your ozzy environment:</p> <p></p><pre><code>git pull\n</code></pre> <pre><code>poetry update\n</code></pre><p></p>"},{"location":"user-guide/installation/virtual-environments/","title":"Virtual environment setup","text":""},{"location":"user-guide/installation/virtual-environments/#virtual-environment-setup","title":"Virtual environment setup","text":"<p>There are several resources out there to guide you through virtual environments and package management with Python. These are our personal recommendations for you to start.</p>"},{"location":"user-guide/installation/virtual-environments/#with-conda-recommended","title":"with conda (recommended)","text":"<p>Note about mamba</p> <p>All <code>conda</code> commands in the following guide can be replaced by <code>mamba</code>. Mamba is a faster version of the conda package manager, and is installed by default with miniforge.</p>"},{"location":"user-guide/installation/virtual-environments/#step-1-follow-online-guide","title":"Step 1 - Follow online guide","text":"<p>Follow this great online guide for installing miniforge and creating virtual environments:</p> <p>Miniforge setup</p> <p>Tip</p> <p>After you've completed the tutorial, you may want to delete the <code>'sklearn-env'</code> environment you created as an example. You can check the list of environments with </p><pre><code>conda env list\n</code></pre> The asterisk shows you which environment is currently active. Make sure to deactivate the <code>'sklearn-env'</code> environment first (with <code>conda deactivate</code>), and then run <pre><code>conda env remove -n sklearn-env\n</code></pre><p></p>"},{"location":"user-guide/installation/virtual-environments/#step-2-create-a-virtual-environment-for-ozzy","title":"Step 2 - Create a virtual environment for ozzy","text":"<p>In your terminal, create a new environment with </p><pre><code>conda create -n ozzy-env\n</code></pre><p></p> <p>Make sure to activate this environment before you install or use ozzy: </p><pre><code>conda activate ozzy-env\n</code></pre><p></p>"},{"location":"user-guide/installation/virtual-environments/#with-venv","title":"with venv","text":""},{"location":"user-guide/installation/virtual-environments/#step-1-install-python","title":"Step 1 - Install Python","text":"<p>Make sure you have Python installed on your system. Ozzy requires the version of Python to be 3.10 or higher.</p>"},{"location":"user-guide/installation/virtual-environments/#step-2-follow-online-guide","title":"Step 2 - Follow online guide","text":"<p>Follow the instructions in the guide for venv, which is a virtual environment tool built into Python:</p> <p>Create and use virtual environments</p>"},{"location":"user-guide/installation/virtual-environments/#step-3-create-a-virtual-environment-for-ozzy","title":"Step 3 - Create a virtual environment for ozzy","text":"<p>In your terminal, create a new environment with </p><pre><code>python3 -m venv .ozzy-env\n</code></pre><p></p> <p>Make sure to activate this environment before you install or use ozzy: </p><pre><code>source .ozzy-env/bin/activate\n</code></pre><p></p>"}]}